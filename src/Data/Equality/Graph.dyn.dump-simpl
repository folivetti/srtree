
==================== Tidy Core ====================
2024-08-21 10:05:25.59361873 UTC

Result size of Tidy Core
  = {terms: 1,880, types: 4,162, coercions: 190, joins: 0/139}

-- RHS size: {terms: 90, types: 158, coercions: 0, joins: 0/5}
repairAnal [InlPrag=INLINE (sat-args=2)]
  :: forall a (l :: * -> *).
     (Analysis a l, Language l) =>
     (ClassId, ENode l) -> EGraph a l -> EGraph a l
[GblId, Arity=4, Unf=OtherCon []]
repairAnal
  = \ (@a_acAW)
      (@(l_acAX :: * -> *))
      ($dAnalysis_acAY :: Analysis a_acAW l_acAX)
      ($dLanguage_acAZ :: Language l_acAX)
      (eta_B0 :: (ClassId, ENode l_acAX))
      (eta1_B1 :: EGraph a_acAW l_acAX) ->
      let {
        $dFunctor_sd0A :: Traversable l_acAX
        [LclId]
        $dFunctor_sd0A
          = Data.Equality.Language.$p2Language @l_acAX $dLanguage_acAZ } in
      let {
        $dFunctor1_acBD :: Functor l_acAX
        [LclId]
        $dFunctor1_acBD
          = Data.Traversable.$p1Traversable @l_acAX $dFunctor_sd0A } in
      let {
        $dEq_acC6 :: Eq a_acAW
        [LclId]
        $dEq_acC6
          = Data.Equality.Analysis.$p1Analysis
              @a_acAW @l_acAX $dAnalysis_acAY } in
      case eta_B0 of { (repair_id_ac8W, node_ac8X) ->
      let {
        c_ac8Z :: EClass a_acAW l_acAX
        [LclId]
        c_ac8Z
          = break<172>(eta1_B1,repair_id_ac8W)
            ^.
              @(EGraph a_acAW l_acAX)
              @(EClass a_acAW l_acAX)
              eta1_B1
              (\ (@(f_acB5 :: * -> *)) ($dFunctor2_acB6 :: Functor f_acB5) ->
                 _class @a_acAW @l_acAX repair_id_ac8W @f_acB5 $dFunctor2_acB6) } in
      let {
        new_data_ac90 :: a_acAW
        [LclId]
        new_data_ac90
          = break<179>(c_ac8Z,eta1_B1,node_ac8X)
            joinA
              @a_acAW
              @l_acAX
              $dAnalysis_acAY
              (break<173>(c_ac8Z)
               ^.
                 @(EClass a_acAW l_acAX)
                 @a_acAW
                 c_ac8Z
                 (_data @a_acAW @l_acAX @a_acAW))
              (break<178>(eta1_B1,node_ac8X)
               makeA
                 @a_acAW
                 @l_acAX
                 $dAnalysis_acAY
                 (break<177>(eta1_B1,node_ac8X)
                  <$>
                    @l_acAX
                    @ClassId
                    @a_acAW
                    $dFunctor1_acBD
                    (\ (i_ac91 :: ClassId) ->
                       break<175>(i_ac91,eta1_B1)
                       ^.
                         @(EClass a_acAW l_acAX)
                         @a_acAW
                         (break<174>(i_ac91,eta1_B1)
                          ^.
                            @(EGraph a_acAW l_acAX)
                            @(EClass a_acAW l_acAX)
                            eta1_B1
                            (\ (@(f_acBI :: * -> *)) ($dFunctor2_acBJ :: Functor f_acBI) ->
                               _class @a_acAW @l_acAX i_ac91 @f_acBI $dFunctor2_acBJ))
                         (_data @a_acAW @l_acAX @a_acAW))
                    (break<176>(node_ac8X) unNode @l_acAX node_ac8X))) } in
      break<191>(c_ac8Z,eta1_B1,new_data_ac90,repair_id_ac8W)
      case break<181>(c_ac8Z,new_data_ac90)
           /=
             @a_acAW
             $dEq_acC6
             (break<180>(c_ac8Z)
              ^.
                @(EClass a_acAW l_acAX)
                @a_acAW
                c_ac8Z
                (_data @a_acAW @l_acAX @a_acAW))
             new_data_ac90
      of {
        False -> eta1_B1;
        True ->
          break<190>(c_ac8Z,eta1_B1,new_data_ac90,repair_id_ac8W)
          & @(EGraph a_acAW l_acAX)
            @(EGraph a_acAW l_acAX)
            (case eta1_B1 of wild2_X3
             { EGraph unionFind_X4 ds_dcXr memo_B3 worklist_B4 ds1_dcXs ->
             case break<188>(eta1_B1,new_data_ac90,repair_id_ac8W)
                  IM.adjust
                    @(EClass a_acAW l_acAX)
                    (break<186>(new_data_ac90)
                     .~
                       @(EClass a_acAW l_acAX)
                       @a_acAW
                       (_data @a_acAW @l_acAX @a_acAW)
                       new_data_ac90)
                    repair_id_ac8W
                    (break<187>(eta1_B1) classes @a_acAW @l_acAX wild2_X3)
             of conrep_ibDI
             { __DEFAULT ->
             case break<185>(c_ac8Z,eta1_B1)
                  <>
                    @(Worklist l_acAX)
                    (GHC.Base.$fSemigroupList @(ClassId, ENode l_acAX))
                    (break<183>(c_ac8Z)
                     toListSL
                       @(ClassId, ENode l_acAX)
                       (break<182>(c_ac8Z)
                        ^.
                          @(EClass a_acAW l_acAX)
                          @(SList (ClassId, ENode l_acAX))
                          c_ac8Z
                          (_parents @a_acAW @l_acAX)))
                    (break<184>(eta1_B1) analysisWorklist @a_acAW @l_acAX wild2_X3)
             of conrep1_ibDL
             { __DEFAULT ->
             Data.Equality.Graph.Internal.EGraph
               @a_acAW
               @l_acAX
               unionFind_X4
               conrep_ibDI
               memo_B3
               worklist_B4
               conrep1_ibDL
             }
             }
             })
            (break<189>(repair_id_ac8W)
             modifyA @a_acAW @l_acAX $dAnalysis_acAY repair_id_ac8W)
      }
      }

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
find [InlPrag=INLINE (sat-args=1)]
  :: forall a (l :: * -> *). ClassId -> EGraph a l -> ClassId
[GblId, Arity=1, Unf=OtherCon []]
find
  = \ (@a_acmP) (@(l_acmQ :: * -> *)) (cid_ac94 :: ClassId) ->
      break<31>(cid_ac94)
      . @ReprUnionFind
        @ClassId
        @(EGraph a_acmP l_acmQ)
        (break<30>(cid_ac94) findRepr cid_ac94)
        (unionFind @a_acmP @l_acmQ)

-- RHS size: {terms: 287, types: 609, coercions: 4, joins: 0/24}
mergeM [InlPrag=INLINABLE]
  :: forall a (l :: * -> *) (m :: * -> *).
     (AM.AnalysisM m a l, Language l) =>
     ClassId -> ClassId -> EGraph a l -> m (ClassId, EGraph a l)
[GblId, Arity=2, Unf=OtherCon []]
mergeM
  = \ (@a_acmY)
      (@(l_acmZ :: * -> *))
      (@(m_acn0 :: * -> *))
      ($dAnalysisM_acn1 :: AM.AnalysisM m_acn0 a_acmY l_acmZ)
      ($dLanguage_acn2 :: Language l_acmZ) ->
      let {
        $dIP_sd0C :: GHC.Stack.Types.CallStack
        [LclId]
        $dIP_sd0C
          = GHC.Stack.Types.pushCallStack
              (ghc-prim:GHC.CString.unpackCString# "assert"#,
               GHC.Stack.Types.SrcLoc
                 (ghc-prim:GHC.CString.unpackCString# "main"#)
                 (ghc-prim:GHC.CString.unpackCString# "Data.Equality.Graph"#)
                 (ghc-prim:GHC.CString.unpackCString#
                    "/home/olivetti/Projects/srtools/srtree/src/Data/Equality/Graph.hs"#)
                 (ghc-prim:GHC.Types.I# 415#)
                 (ghc-prim:GHC.Types.I# 48#)
                 (ghc-prim:GHC.Types.I# 415#)
                 (ghc-prim:GHC.Types.I# 54#))
              GHC.Stack.Types.emptyCallStack } in
      let {
        $dOrd_acPJ :: Ord (l_acmZ ClassId)
        [LclId]
        $dOrd_acPJ
          = Data.Equality.Language.$p1Language
              @l_acmZ $dLanguage_acn2 @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dOrd1_acPI :: Ord (ENode l_acmZ)
        [LclId]
        $dOrd1_acPI
          = Data.Equality.Graph.Nodes.$fOrdENode @l_acmZ $dOrd_acPJ } in
      let {
        $dSemigroup_acry :: Semigroup (S.Set (ENode l_acmZ))
        [LclId]
        $dSemigroup_acry
          = Data.Set.Internal.$fSemigroupSet @(ENode l_acmZ) $dOrd1_acPI } in
      let {
        $dEq_acPB :: Eq a_acmY
        [LclId]
        $dEq_acPB
          = Data.Equality.Analysis.Monadic.$p2AnalysisM
              @m_acn0 @a_acmY @l_acmZ $dAnalysisM_acn1 } in
      let {
        $dMonad_acPy :: Monad m_acn0
        [LclId]
        $dMonad_acPy
          = Data.Equality.Analysis.Monadic.$p1AnalysisM
              @m_acn0 @a_acmY @l_acmZ $dAnalysisM_acn1 } in
      \ (a1_ac9t :: ClassId)
        (b_ac9u :: ClassId)
        (egr0_ac9v :: EGraph a_acmY l_acmZ) ->
        break<90>(a1_ac9t,b_ac9u,egr0_ac9v)
        let {
          b'_ac9x :: ClassId
          [LclId]
          b'_ac9x
            = break<32>(b_ac9u,egr0_ac9v)
              (break<31>(b_ac9u)
               . @ReprUnionFind
                 @ClassId
                 @(EGraph a_acmY l_acmZ)
                 (break<30>(b_ac9u) findRepr b_ac9u)
                 (unionFind @a_acmY @l_acmZ))
                egr0_ac9v } in
        let {
          a'_ac9w :: ClassId
          [LclId]
          a'_ac9w
            = break<33>(a1_ac9t,egr0_ac9v)
              (break<31>(a1_ac9t)
               . @ReprUnionFind
                 @ClassId
                 @(EGraph a_acmY l_acmZ)
                 (break<30>(a1_ac9t) findRepr a1_ac9t)
                 (unionFind @a_acmY @l_acmZ))
                egr0_ac9v } in
        break<89>(a'_ac9w,b'_ac9x,egr0_ac9v)
        case break<34>(a'_ac9w,b'_ac9x)
             == @ClassId ghc-prim:GHC.Classes.$fEqInt a'_ac9w b'_ac9x
        of {
          False ->
            let {
              class_b_ac9z :: EClass a_acmY l_acmZ
              [LclId]
              class_b_ac9z
                = break<36>(b'_ac9x,egr0_ac9v)
                  ^.
                    @(EGraph a_acmY l_acmZ)
                    @(EClass a_acmY l_acmZ)
                    egr0_ac9v
                    (\ (@(f_acnl :: * -> *)) ($dFunctor_acnm :: Functor f_acnl) ->
                       _class @a_acmY @l_acmZ b'_ac9x @f_acnl $dFunctor_acnm) } in
            let {
              class_a_ac9y :: EClass a_acmY l_acmZ
              [LclId]
              class_a_ac9y
                = break<37>(a'_ac9w,egr0_ac9v)
                  ^.
                    @(EGraph a_acmY l_acmZ)
                    @(EClass a_acmY l_acmZ)
                    egr0_ac9v
                    (\ (@(f_acnz :: * -> *)) ($dFunctor_acnA :: Functor f_acnz) ->
                       _class @a_acmY @l_acmZ a'_ac9w @f_acnz $dFunctor_acnA) } in
            let {
              ds_dcU7
                :: (ClassId, EClass a_acmY l_acmZ, ClassId, EClass a_acmY l_acmZ)
              [LclId]
              ds_dcU7
                = break<43>(a'_ac9w,b'_ac9x,class_a_ac9y,class_b_ac9z)
                  case break<42>(class_a_ac9y,class_b_ac9z)
                       < @Int
                         ghc-prim:GHC.Classes.$fOrdInt
                         (break<39>(class_a_ac9y)
                          sizeSL
                            @(ClassId, ENode l_acmZ)
                            (break<38>(class_a_ac9y)
                             ^.
                               @(EClass a_acmY l_acmZ)
                               @(SList (ClassId, ENode l_acmZ))
                               class_a_ac9y
                               (_parents @a_acmY @l_acmZ)))
                         (break<41>(class_b_ac9z)
                          sizeSL
                            @(ClassId, ENode l_acmZ)
                            (break<40>(class_b_ac9z)
                             ^.
                               @(EClass a_acmY l_acmZ)
                               @(SList (ClassId, ENode l_acmZ))
                               class_b_ac9z
                               (_parents @a_acmY @l_acmZ)))
                  of {
                    False -> (a'_ac9w, class_a_ac9y, b'_ac9x, class_b_ac9z);
                    True -> (b'_ac9x, class_b_ac9z, a'_ac9w, class_a_ac9y)
                  } } in
            let {
              leader_ac9A :: ClassId
              [LclId]
              leader_ac9A
                = case ds_dcU7 of
                  { (leader1_X3, leader_class_ac9B, sub_ac9C, sub_class_ac9D) ->
                  leader1_X3
                  } } in
            let {
              leader_class_ac9B :: EClass a_acmY l_acmZ
              [LclId]
              leader_class_ac9B
                = case ds_dcU7 of
                  { (leader1_X3, leader_class1_X4, sub_ac9C, sub_class_ac9D) ->
                  leader_class1_X4
                  } } in
            let {
              sub_ac9C :: ClassId
              [LclId]
              sub_ac9C
                = case ds_dcU7 of
                  { (leader1_X3, leader_class1_X4, sub1_X5, sub_class_ac9D) ->
                  sub1_X5
                  } } in
            let {
              sub_class_ac9D :: EClass a_acmY l_acmZ
              [LclId]
              sub_class_ac9D
                = case ds_dcU7 of
                  { (leader1_X3, leader_class1_X4, sub1_X5, sub_class1_X6) ->
                  sub_class1_X6
                  } } in
            let {
              ds1_dcU6 :: (ClassId, ReprUnionFind)
              [LclId]
              ds1_dcU6
                = break<49>(egr0_ac9v,leader_ac9A,sub_ac9C)
                  & @(ClassId, ReprUnionFind)
                    @(ClassId, ReprUnionFind)
                    (break<45>(egr0_ac9v,leader_ac9A,sub_ac9C)
                     unionSets
                       leader_ac9A
                       sub_ac9C
                       (break<44>(egr0_ac9v) unionFind @a_acmY @l_acmZ egr0_ac9v))
                    (break<48>(leader_ac9A)
                     first
                       @(,)
                       Data.Bifunctor.$fBifunctor(,)
                       @ClassId
                       @ClassId
                       @ReprUnionFind
                       (\ (n_ac9G :: ClassId) ->
                          break<47>(n_ac9G,leader_ac9A)
                          GHC.IO.Exception.assertError
                            @ClassId
                            ($dIP_sd0C
                             `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                              <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                     :: GHC.Stack.Types.CallStack
                                        ~R# (?callStack::GHC.Stack.Types.CallStack)))
                            (break<46>(n_ac9G,leader_ac9A)
                             == @ClassId ghc-prim:GHC.Classes.$fEqInt leader_ac9A n_ac9G)
                            n_ac9G)) } in
            let {
              new_id_ac9E :: ClassId
              [LclId]
              new_id_ac9E
                = case ds1_dcU6 of { (new_id1_X3, new_uf_ac9F) -> new_id1_X3 } } in
            let {
              new_uf_ac9F :: ReprUnionFind
              [LclId]
              new_uf_ac9F
                = case ds1_dcU6 of { (new_id1_X3, new_uf1_X4) -> new_uf1_X4 } } in
            >>=
              @m_acn0
              $dMonad_acPy
              @a_acmY
              @(ClassId, EGraph a_acmY l_acmZ)
              (break<52>(leader_class_ac9B,sub_class_ac9D)
               AM.joinA
                 @m_acn0
                 @a_acmY
                 @l_acmZ
                 $dAnalysisM_acn1
                 (break<50>(leader_class_ac9B)
                  ^.
                    @(EClass a_acmY l_acmZ)
                    @a_acmY
                    leader_class_ac9B
                    (_data @a_acmY @l_acmZ @a_acmY))
                 (break<51>(sub_class_ac9D)
                  ^.
                    @(EClass a_acmY l_acmZ)
                    @a_acmY
                    sub_class_ac9D
                    (_data @a_acmY @l_acmZ @a_acmY)))
              (\ (new_data_ac9H :: a_acmY) ->
                 let {
                   new_analysis_worklist_ac9L :: [(ClassId, ENode l_acmZ)]
                   [LclId]
                   new_analysis_worklist_ac9L
                     = break<63>(egr0_ac9v,leader_class_ac9B,sub_class_ac9D,new_data_ac9H)
                       <>
                         @[(ClassId, ENode l_acmZ)]
                         (GHC.Base.$fSemigroupList @(ClassId, ENode l_acmZ))
                         (case break<54>(sub_class_ac9D,new_data_ac9H)
                               /=
                                 @a_acmY
                                 $dEq_acPB
                                 new_data_ac9H
                                 (break<53>(sub_class_ac9D)
                                  ^.
                                    @(EClass a_acmY l_acmZ)
                                    @a_acmY
                                    sub_class_ac9D
                                    (_data @a_acmY @l_acmZ @a_acmY))
                          of {
                            False ->
                              mempty
                                @[(ClassId, ENode l_acmZ)]
                                (GHC.Base.$fMonoidList @(ClassId, ENode l_acmZ));
                            True ->
                              break<56>(sub_class_ac9D)
                              toListSL
                                @(ClassId, ENode l_acmZ)
                                (break<55>(sub_class_ac9D)
                                 ^.
                                   @(EClass a_acmY l_acmZ)
                                   @(SList (ClassId, ENode l_acmZ))
                                   sub_class_ac9D
                                   (_parents @a_acmY @l_acmZ))
                          })
                         (break<62>(egr0_ac9v,leader_class_ac9B,new_data_ac9H)
                          <>
                            @[(ClassId, ENode l_acmZ)]
                            (GHC.Base.$fSemigroupList @(ClassId, ENode l_acmZ))
                            (case break<58>(leader_class_ac9B,new_data_ac9H)
                                  /=
                                    @a_acmY
                                    $dEq_acPB
                                    new_data_ac9H
                                    (break<57>(leader_class_ac9B)
                                     ^.
                                       @(EClass a_acmY l_acmZ)
                                       @a_acmY
                                       leader_class_ac9B
                                       (_data @a_acmY @l_acmZ @a_acmY))
                             of {
                               False ->
                                 mempty
                                   @[(ClassId, ENode l_acmZ)]
                                   (GHC.Base.$fMonoidList @(ClassId, ENode l_acmZ));
                               True ->
                                 break<60>(leader_class_ac9B)
                                 toListSL
                                   @(ClassId, ENode l_acmZ)
                                   (break<59>(leader_class_ac9B)
                                    ^.
                                      @(EClass a_acmY l_acmZ)
                                      @(SList (ClassId, ENode l_acmZ))
                                      leader_class_ac9B
                                      (_parents @a_acmY @l_acmZ))
                             })
                            (break<61>(egr0_ac9v)
                             analysisWorklist @a_acmY @l_acmZ egr0_ac9v)) } in
                 let {
                   new_worklist_ac9K :: [(ClassId, ENode l_acmZ)]
                   [LclId]
                   new_worklist_ac9K
                     = break<67>(egr0_ac9v,sub_class_ac9D)
                       <>
                         @[(ClassId, ENode l_acmZ)]
                         (GHC.Base.$fSemigroupList @(ClassId, ENode l_acmZ))
                         (break<65>(sub_class_ac9D)
                          toListSL
                            @(ClassId, ENode l_acmZ)
                            (break<64>(sub_class_ac9D)
                             ^.
                               @(EClass a_acmY l_acmZ)
                               @(SList (ClassId, ENode l_acmZ))
                               sub_class_ac9D
                               (_parents @a_acmY @l_acmZ)))
                         (break<66>(egr0_ac9v) worklist @a_acmY @l_acmZ egr0_ac9v) } in
                 let {
                   updatedLeader_ac9I :: EClass a_acmY l_acmZ
                   [LclId]
                   updatedLeader_ac9I
                     = break<77>(leader_class_ac9B,sub_class_ac9D,new_data_ac9H)
                       & @(EClass a_acmY l_acmZ)
                         @(EClass a_acmY l_acmZ)
                         (break<75>(leader_class_ac9B,sub_class_ac9D)
                          & @(EClass a_acmY l_acmZ)
                            @(EClass a_acmY l_acmZ)
                            (break<71>(leader_class_ac9B,sub_class_ac9D)
                             & @(EClass a_acmY l_acmZ)
                               @(EClass a_acmY l_acmZ)
                               leader_class_ac9B
                               (break<70>(sub_class_ac9D)
                                %~
                                  @(EClass a_acmY l_acmZ)
                                  @(EClass a_acmY l_acmZ)
                                  @(SList (ClassId, ENode l_acmZ))
                                  @(SList (ClassId, ENode l_acmZ))
                                  (_parents
                                     @a_acmY
                                     @l_acmZ
                                     @Data.Functor.Identity.Identity
                                     Data.Functor.Identity.$fFunctorIdentity)
                                  (break<69>(sub_class_ac9D)
                                   let {
                                     v_B1
                                       :: SList (ClassId, ENode l_acmZ)
                                          -> SList (ClassId, ENode l_acmZ)
                                     [LclId]
                                     v_B1
                                       = <>
                                           @(SList (ClassId, ENode l_acmZ))
                                           (Data.Equality.Utils.SizedList.$fSemigroupSList
                                              @(ClassId, ENode l_acmZ))
                                           (break<68>(sub_class_ac9D)
                                            ^.
                                              @(EClass a_acmY l_acmZ)
                                              @(SList (ClassId, ENode l_acmZ))
                                              sub_class_ac9D
                                              (_parents @a_acmY @l_acmZ)) } in
                                   \ (v1_B2 :: SList (ClassId, ENode l_acmZ)) -> v_B1 v1_B2)))
                            (break<74>(sub_class_ac9D)
                             %~
                               @(EClass a_acmY l_acmZ)
                               @(EClass a_acmY l_acmZ)
                               @(S.Set (ENode l_acmZ))
                               @(S.Set (ENode l_acmZ))
                               (_nodes
                                  @a_acmY
                                  @l_acmZ
                                  @Data.Functor.Identity.Identity
                                  Data.Functor.Identity.$fFunctorIdentity)
                               (break<73>(sub_class_ac9D)
                                let {
                                  v_B1 :: S.Set (ENode l_acmZ) -> S.Set (ENode l_acmZ)
                                  [LclId]
                                  v_B1
                                    = <>
                                        @(S.Set (ENode l_acmZ))
                                        $dSemigroup_acry
                                        (break<72>(sub_class_ac9D)
                                         ^.
                                           @(EClass a_acmY l_acmZ)
                                           @(S.Set (ENode l_acmZ))
                                           sub_class_ac9D
                                           (_nodes @a_acmY @l_acmZ)) } in
                                \ (v1_B2 :: S.Set (ENode l_acmZ)) -> v_B1 v1_B2)))
                         (break<76>(new_data_ac9H)
                          .~
                            @(EClass a_acmY l_acmZ)
                            @a_acmY
                            (_data @a_acmY @l_acmZ @a_acmY)
                            new_data_ac9H) } in
                 let {
                   new_classes_ac9J :: IM.IntMap (EClass a_acmY l_acmZ)
                   [LclId]
                   new_classes_ac9J
                     = break<81>(egr0_ac9v,leader_ac9A,sub_ac9C,updatedLeader_ac9I)
                       . @(IM.IntMap (EClass a_acmY l_acmZ))
                         @(IM.IntMap (EClass a_acmY l_acmZ))
                         @(IM.IntMap (EClass a_acmY l_acmZ))
                         (break<78>(leader_ac9A,updatedLeader_ac9I)
                          IM.insert @(EClass a_acmY l_acmZ) leader_ac9A updatedLeader_ac9I)
                         (break<79>(sub_ac9C) IM.delete @(EClass a_acmY l_acmZ) sub_ac9C)
                         (break<80>(egr0_ac9v) classes @a_acmY @l_acmZ egr0_ac9v) } in
                 >>=
                   @m_acn0
                   $dMonad_acPy
                   @(EGraph a_acmY l_acmZ)
                   @(ClassId, EGraph a_acmY l_acmZ)
                   (break<87>(new_uf_ac9F,new_classes_ac9J,new_worklist_ac9K,egr0_ac9v,new_id_ac9E,new_analysis_worklist_ac9L)
                    & @(EGraph a_acmY l_acmZ)
                      @(m_acn0 (EGraph a_acmY l_acmZ))
                      (case egr0_ac9v of
                       { EGraph ds2_dcU2 ds3_dcU3 memo_B3 ds4_dcU4 ds5_dcU5 ->
                       case break<82>(new_uf_ac9F) new_uf_ac9F of conrep_ibDH
                       { Data.Equality.Graph.ReprUnionFind.RUF ipv_sd0D ipv1_sd0E ->
                       case break<83>(new_classes_ac9J) new_classes_ac9J of conrep1_ibDI
                       { __DEFAULT ->
                       case break<84>(new_worklist_ac9K) new_worklist_ac9K of conrep2_ibDK
                       { __DEFAULT ->
                       case break<85>(new_analysis_worklist_ac9L)
                            new_analysis_worklist_ac9L
                       of conrep3_ibDL
                       { __DEFAULT ->
                       Data.Equality.Graph.Internal.EGraph
                         @a_acmY
                         @l_acmZ
                         conrep_ibDH
                         conrep1_ibDI
                         memo_B3
                         conrep2_ibDK
                         conrep3_ibDL
                       }
                       }
                       }
                       }
                       })
                      (break<86>(new_id_ac9E)
                       AM.modifyA @m_acn0 @a_acmY @l_acmZ $dAnalysisM_acn1 new_id_ac9E))
                   (\ (egr1_ac9M :: EGraph a_acmY l_acmZ) ->
                      break<88>(new_id_ac9E,egr1_ac9M)
                      return
                        @m_acn0
                        $dMonad_acPy
                        @(ClassId, EGraph a_acmY l_acmZ)
                        (new_id_ac9E, egr1_ac9M)));
          True ->
            break<35>(a'_ac9w,egr0_ac9v)
            return
              @m_acn0
              $dMonad_acPy
              @(ClassId, EGraph a_acmY l_acmZ)
              (a'_ac9w, egr0_ac9v)
        }

-- RHS size: {terms: 70, types: 127, coercions: 14, joins: 0/4}
repairM [InlPrag=INLINE (sat-args=2)]
  :: forall a (l :: * -> *) (m :: * -> *).
     (AM.AnalysisM m a l, Language l) =>
     (ClassId, ENode l) -> EGraph a l -> m (EGraph a l)
[GblId, Arity=2, Unf=OtherCon []]
repairM
  = \ (@a_acsL)
      (@(l_acsM :: * -> *))
      (@(m_acsN :: * -> *))
      ($dAnalysisM_acsO :: AM.AnalysisM m_acsN a_acsL l_acsM)
      ($dLanguage_acsP :: Language l_acsM) ->
      let {
        $dOrd_acsX :: Ord (l_acsM ClassId)
        [LclId]
        $dOrd_acsX
          = Data.Equality.Language.$p1Language
              @l_acsM $dLanguage_acsP @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dMonad_acQ2 :: Monad m_acsN
        [LclId]
        $dMonad_acQ2
          = Data.Equality.Analysis.Monadic.$p1AnalysisM
              @m_acsN @a_acsL @l_acsM $dAnalysisM_acsO } in
      let {
        $dFunctor_sd0H :: Applicative m_acsN
        [LclId]
        $dFunctor_sd0H = GHC.Base.$p1Monad @m_acsN $dMonad_acQ2 } in
      let {
        $dFunctor1_acts :: Functor m_acsN
        [LclId]
        $dFunctor1_acts
          = GHC.Base.$p1Applicative @m_acsN $dFunctor_sd0H } in
      \ (ds_dcU8 :: (ClassId, ENode l_acsM))
        (egr_ac9Z :: EGraph a_acsL l_acsM) ->
        case ds_dcU8 of { (repair_id_ac9X, node_ac9Y) ->
        break<98>(egr_ac9Z,repair_id_ac9X,node_ac9Y)
        case break<92>(egr_ac9Z,repair_id_ac9X,node_ac9Y)
             insertLookupNM
               @l_acsM
               @ClassId
               $dOrd_acsX
               node_ac9Y
               repair_id_ac9X
               (break<91>(egr_ac9Z) memo @a_acsL @l_acsM egr_ac9Z)
        of
        { (ds1_dcUE, memo'_aca0) ->
        case ds1_dcUE of {
          Nothing ->
            break<94>(egr_ac9Z,memo'_aca0)
            $ @ghc-prim:GHC.Types.LiftedRep
              @(EGraph a_acsL l_acsM)
              @(m_acsN (EGraph a_acsL l_acsM))
              (return @m_acsN $dMonad_acQ2 @(EGraph a_acsL l_acsM))
              (case egr_ac9Z of
               { EGraph unionFind_B1 classes_B2 ds2_dcUw worklist_B4
                        analysisWorklist_B5 ->
               case (break<93>(memo'_aca0) memo'_aca0)
                    `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                <l_acsM>_N <ClassId>_N
                            :: NodeMap l_acsM ClassId
                               ~R# Data.Map.Internal.Map (ENode l_acsM) ClassId)
               of nt_sd0I
               { __DEFAULT ->
               Data.Equality.Graph.Internal.EGraph
                 @a_acsL
                 @l_acsM
                 unionFind_B1
                 classes_B2
                 (nt_sd0I
                  `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                   <l_acsM>_N) <ClassId>_N
                          :: Data.Map.Internal.Map (ENode l_acsM) ClassId
                             ~R# NodeMap l_acsM ClassId))
                 worklist_B4
                 analysisWorklist_B5
               }
               });
          Just existing_class_aca1 ->
            break<97>(egr_ac9Z,repair_id_ac9X,memo'_aca0,existing_class_aca1)
            <$>
              @m_acsN
              @(ClassId, EGraph a_acsL l_acsM)
              @(EGraph a_acsL l_acsM)
              $dFunctor1_acts
              (snd @ClassId @(EGraph a_acsL l_acsM))
              (break<96>(egr_ac9Z,repair_id_ac9X,memo'_aca0,existing_class_aca1)
               mergeM
                 @a_acsL
                 @l_acsM
                 @m_acsN
                 $dAnalysisM_acsO
                 $dLanguage_acsP
                 existing_class_aca1
                 repair_id_ac9X
                 (case egr_ac9Z of
                  { EGraph unionFind_B1 classes_B2 ds2_dcUD worklist_B4
                           analysisWorklist_B5 ->
                  case (break<95>(memo'_aca0) memo'_aca0)
                       `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                   <l_acsM>_N <ClassId>_N
                               :: NodeMap l_acsM ClassId
                                  ~R# Data.Map.Internal.Map (ENode l_acsM) ClassId)
                  of nt_sd0J
                  { __DEFAULT ->
                  Data.Equality.Graph.Internal.EGraph
                    @a_acsL
                    @l_acsM
                    unionFind_B1
                    classes_B2
                    (nt_sd0J
                     `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                      <l_acsM>_N) <ClassId>_N
                             :: Data.Map.Internal.Map (ENode l_acsM) ClassId
                                ~R# NodeMap l_acsM ClassId))
                    worklist_B4
                    analysisWorklist_B5
                  }
                  }))
        }
        }
        }

-- RHS size: {terms: 17, types: 28, coercions: 9, joins: 0/0}
canonicalize [InlPrag=INLINE (sat-args=2)]
  :: forall (l :: * -> *) a.
     Functor l =>
     ENode l -> EGraph a l -> ENode l
[GblId, Arity=3, Unf=OtherCon []]
canonicalize
  = \ (@(l_actT :: * -> *))
      (@a_actU)
      ($dFunctor_actV :: Functor l_actT)
      (eta_B0 :: ENode l_actT)
      (eg_ac93 :: EGraph a_actU l_actT) ->
      break<101>(eta_B0,eg_ac93)
      $ @ghc-prim:GHC.Types.LiftedRep
        @(l_actT ClassId)
        @(ENode l_actT)
        ((\ (ds_dcUI :: l_actT ClassId) -> ds_dcUI)
         `cast` (<l_actT ClassId>_R
                 %<Many>_N ->_R Sym (Data.Equality.Graph.Nodes.N:ENode[0]
                                         <l_actT>_R)
                 :: (l_actT ClassId -> l_actT ClassId)
                    ~R# (l_actT ClassId -> ENode l_actT)))
        (break<100>(eta_B0,eg_ac93)
         fmap
           @l_actT
           $dFunctor_actV
           @ClassId
           @ClassId
           (break<99>(eg_ac93)
            \ (v_B2 :: ClassId) ->
              (break<31>(v_B2)
               . @ReprUnionFind
                 @ClassId
                 @(EGraph a_actU l_actT)
                 (break<30>(v_B2) findRepr v_B2)
                 (unionFind @a_actU @l_actT))
                eg_ac93)
           (eta_B0
            `cast` (Data.Equality.Graph.Nodes.N:ENode[0] <l_actT>_R
                    :: ENode l_actT ~R# l_actT ClassId)))

-- RHS size: {terms: 186, types: 352, coercions: 39, joins: 0/17}
addM [InlPrag=INLINABLE]
  :: forall a (l :: * -> *) (m :: * -> *).
     (AM.AnalysisM m a l, Language l) =>
     ENode l -> EGraph a l -> m (ClassId, EGraph a l)
[GblId, Arity=2, Unf=OtherCon []]
addM
  = \ (@a_acuj)
      (@(l_acuk :: * -> *))
      (@(m_acul :: * -> *))
      ($dAnalysisM_acum :: AM.AnalysisM m_acul a_acuj l_acuk)
      ($dLanguage_acun :: Language l_acuk) ->
      let {
        $dTraversable_acQh :: Traversable l_acuk
        [LclId]
        $dTraversable_acQh
          = Data.Equality.Language.$p2Language @l_acuk $dLanguage_acun } in
      let {
        $dFunctor_acQi :: Functor l_acuk
        [LclId]
        $dFunctor_acQi
          = Data.Traversable.$p1Traversable @l_acuk $dTraversable_acQh } in
      let {
        $dFoldable_acw5 :: Foldable l_acuk
        [LclId]
        $dFoldable_acw5
          = Data.Traversable.$p2Traversable @l_acuk $dTraversable_acQh } in
      let {
        df_acQg :: forall {a1}. Ord a1 => Ord (l_acuk a1)
        [LclId]
        df_acQg
          = \ (@a1_i6hG) ->
              Data.Equality.Language.$p1Language
                @l_acuk $dLanguage_acun @a1_i6hG } in
      let {
        $dOrd_acuA :: Ord (l_acuk ClassId)
        [LclId]
        $dOrd_acuA = df_acQg @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dOrd1_acvp :: Ord (l_acuk ClassId)
        [LclId]
        $dOrd1_acvp = df_acQg @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dMonad_acQc :: Monad m_acul
        [LclId]
        $dMonad_acQc
          = Data.Equality.Analysis.Monadic.$p1AnalysisM
              @m_acul @a_acuj @l_acuk $dAnalysisM_acum } in
      let {
        $dApplicative_acuF :: Applicative m_acul
        [LclId]
        $dApplicative_acuF = GHC.Base.$p1Monad @m_acul $dMonad_acQc } in
      \ (uncanon_e_ac9f :: ENode l_acuk)
        (egr_ac9g :: EGraph a_acuj l_acuk) ->
        case (break<102>(egr_ac9g,uncanon_e_ac9f)
              break<101>(uncanon_e_ac9f,egr_ac9g)
              $ @ghc-prim:GHC.Types.LiftedRep
                @(l_acuk ClassId)
                @(ENode l_acuk)
                ((\ (ds_dcUI :: l_acuk ClassId) -> ds_dcUI)
                 `cast` (<l_acuk ClassId>_R
                         %<Many>_N ->_R Sym (Data.Equality.Graph.Nodes.N:ENode[0]
                                                 <l_acuk>_R)
                         :: (l_acuk ClassId -> l_acuk ClassId)
                            ~R# (l_acuk ClassId -> ENode l_acuk)))
                (break<100>(uncanon_e_ac9f,egr_ac9g)
                 fmap
                   @l_acuk
                   $dFunctor_acQi
                   @ClassId
                   @ClassId
                   (break<99>(egr_ac9g)
                    \ (v_B2 :: ClassId) ->
                      (break<31>(v_B2)
                       . @ReprUnionFind
                         @ClassId
                         @(EGraph a_acuj l_acuk)
                         (break<30>(v_B2) findRepr v_B2)
                         (unionFind @a_acuj @l_acuk))
                        egr_ac9g)
                   (uncanon_e_ac9f
                    `cast` (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R
                            :: ENode l_acuk ~R# l_acuk ClassId))))
             `cast` (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R
                     :: ENode l_acuk ~R# l_acuk ClassId)
        of nt_sd0L
        { __DEFAULT ->
        break<136>(egr_ac9g,nt_sd0L)
        case break<104>(egr_ac9g,nt_sd0L)
             lookupNM
               @l_acuk
               @ClassId
               $dOrd_acuA
               (nt_sd0L
                `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R)
                        :: l_acuk ClassId ~R# ENode l_acuk))
               (break<103>(egr_ac9g) memo @a_acuj @l_acuk egr_ac9g)
        of {
          Nothing ->
            break<135>(egr_ac9g,nt_sd0L)
            let {
              ds_dcVf :: (ClassId, ReprUnionFind)
              [LclId]
              ds_dcVf
                = break<108>(egr_ac9g)
                  makeNewSet
                    (break<107>(egr_ac9g) unionFind @a_acuj @l_acuk egr_ac9g) } in
            let {
              new_eclass_id_ac9j :: ClassId
              [LclId]
              new_eclass_id_ac9j
                = case ds_dcVf of { (new_eclass_id1_X3, new_uf_ac9k) ->
                  new_eclass_id1_X3
                  } } in
            let {
              new_uf_ac9k :: ReprUnionFind
              [LclId]
              new_uf_ac9k
                = case ds_dcVf of { (new_eclass_id1_X3, new_uf1_X4) ->
                  new_uf1_X4
                  } } in
            >>=
              @m_acul
              $dMonad_acQc
              @a_acuj
              @(ClassId, EGraph a_acuj l_acuk)
              (break<112>(egr_ac9g,nt_sd0L)
               AM.makeA
                 @m_acul
                 @a_acuj
                 @l_acuk
                 $dAnalysisM_acum
                 (break<111>(egr_ac9g,nt_sd0L)
                  <$>
                    @l_acuk
                    @ClassId
                    @a_acuj
                    $dFunctor_acQi
                    (\ (i_ac9l :: ClassId) ->
                       break<109>(i_ac9l,egr_ac9g)
                       ^.
                         @(EGraph a_acuj l_acuk)
                         @a_acuj
                         egr_ac9g
                         (\ (@(f_acv1 :: * -> *)) ($dFunctor1_acv2 :: Functor f_acv1) ->
                            . @(EClass a_acuj l_acuk -> f_acv1 (EClass a_acuj l_acuk))
                              @(EGraph a_acuj l_acuk -> f_acv1 (EGraph a_acuj l_acuk))
                              @(a_acuj -> f_acv1 a_acuj)
                              (_class @a_acuj @l_acuk i_ac9l @f_acv1 $dFunctor1_acv2)
                              (_data @a_acuj @l_acuk @a_acuj @f_acv1 $dFunctor1_acv2)))
                    (break<110>(nt_sd0L)
                     unNode
                       @l_acuk
                       (nt_sd0L
                        `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R)
                                :: l_acuk ClassId ~R# ENode l_acuk)))))
              (\ (new_data_ac9m :: a_acuj) ->
                 let {
                   new_memo_ac9r :: NodeMap l_acuk ClassId
                   [LclId]
                   new_memo_ac9r
                     = break<114>(egr_ac9g,nt_sd0L,new_eclass_id_ac9j)
                       insertNM
                         @l_acuk
                         @ClassId
                         $dOrd1_acvp
                         (nt_sd0L
                          `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R)
                                  :: l_acuk ClassId ~R# ENode l_acuk))
                         new_eclass_id_ac9j
                         (break<113>(egr_ac9g) memo @a_acuj @l_acuk egr_ac9g) } in
                 let {
                   new_worklist_ac9q :: [(ClassId, ENode l_acuk)]
                   [LclId]
                   new_worklist_ac9q
                     = break<116>(egr_ac9g,nt_sd0L,new_eclass_id_ac9j)
                       ghc-prim:GHC.Types.:
                         @(ClassId, ENode l_acuk)
                         (new_eclass_id_ac9j,
                          nt_sd0L
                          `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R)
                                  :: l_acuk ClassId ~R# ENode l_acuk))
                         (break<115>(egr_ac9g) worklist @a_acuj @l_acuk egr_ac9g) } in
                 let {
                   new_parents_ac9o
                     :: SList (ClassId, ENode l_acuk) -> SList (ClassId, ENode l_acuk)
                   [LclId]
                   new_parents_ac9o
                     = break<118>(nt_sd0L,new_eclass_id_ac9j)
                       break<117>(nt_sd0L,new_eclass_id_ac9j)
                       let {
                         v_B1
                           :: SList (ClassId, ENode l_acuk) -> SList (ClassId, ENode l_acuk)
                         [LclId]
                         v_B1
                           = |:
                               @(ClassId, ENode l_acuk)
                               (new_eclass_id_ac9j,
                                nt_sd0L
                                `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R)
                                        :: l_acuk ClassId ~R# ENode l_acuk)) } in
                       \ (v1_B2 :: SList (ClassId, ENode l_acuk)) -> v_B1 v1_B2 } in
                 let {
                   new_eclass_ac9n :: EClass a_acuj l_acuk
                   [LclId]
                   new_eclass_ac9n
                     = break<120>(nt_sd0L,new_eclass_id_ac9j,new_data_ac9m)
                       case new_eclass_id_ac9j of conrep_ibq6
                       { ghc-prim:GHC.Types.I# ipv_sd0M ->
                       case break<119>(nt_sd0L)
                            S.singleton
                              @(ENode l_acuk)
                              (nt_sd0L
                               `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R)
                                       :: l_acuk ClassId ~R# ENode l_acuk))
                       of conrep1_ibq7
                       { __DEFAULT ->
                       case mempty
                              @(SList (ClassId, ENode l_acuk))
                              (Data.Equality.Utils.SizedList.$fMonoidSList
                                 @(ClassId, ENode l_acuk))
                       of conrep2_ibq9
                       { SList ipv1_sd0O ipv2_sd0P ->
                       Data.Equality.Graph.Classes.EClass
                         @a_acuj @l_acuk conrep_ibq6 conrep1_ibq7 new_data_ac9m conrep2_ibq9
                       }
                       }
                       } } in
                 let {
                   new_classes_ac9p :: IM.IntMap (EClass a_acuj l_acuk)
                   [LclId]
                   new_classes_ac9p
                     = break<127>(egr_ac9g,nt_sd0L,new_eclass_id_ac9j,new_eclass_ac9n,new_parents_ac9o)
                       $ @ghc-prim:GHC.Types.LiftedRep
                         @(IM.IntMap (EClass a_acuj l_acuk))
                         @(IM.IntMap (EClass a_acuj l_acuk))
                         (break<121>(new_eclass_id_ac9j,new_eclass_ac9n)
                          IM.insert
                            @(EClass a_acuj l_acuk) new_eclass_id_ac9j new_eclass_ac9n)
                         (break<126>(egr_ac9g,nt_sd0L,new_parents_ac9o)
                          foldr
                            @l_acuk
                            $dFoldable_acw5
                            @IM.Key
                            @(IM.IntMap (EClass a_acuj l_acuk))
                            (break<123>(new_parents_ac9o)
                             IM.adjust
                               @(EClass a_acuj l_acuk)
                               (break<122>(new_parents_ac9o)
                                %~
                                  @(EClass a_acuj l_acuk)
                                  @(EClass a_acuj l_acuk)
                                  @(SList (ClassId, ENode l_acuk))
                                  @(SList (ClassId, ENode l_acuk))
                                  (_parents
                                     @a_acuj
                                     @l_acuk
                                     @Data.Functor.Identity.Identity
                                     Data.Functor.Identity.$fFunctorIdentity)
                                  new_parents_ac9o))
                            (break<124>(egr_ac9g) classes @a_acuj @l_acuk egr_ac9g)
                            (break<125>(nt_sd0L)
                             unNode
                               @l_acuk
                               (nt_sd0L
                                `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acuk>_R)
                                        :: l_acuk ClassId ~R# ENode l_acuk)))) } in
                 >>=
                   @m_acul
                   $dMonad_acQc
                   @(EGraph a_acuj l_acuk)
                   @(ClassId, EGraph a_acuj l_acuk)
                   (break<133>(egr_ac9g,new_eclass_id_ac9j,new_uf_ac9k,new_classes_ac9p,new_worklist_ac9q,new_memo_ac9r)
                    & @(EGraph a_acuj l_acuk)
                      @(m_acul (EGraph a_acuj l_acuk))
                      (case egr_ac9g of
                       { EGraph ds1_dcV3 ds2_dcV4 ds3_dcV5 ds4_dcV6 analysisWorklist_B5 ->
                       case break<128>(new_uf_ac9k) new_uf_ac9k of conrep_ibDH
                       { Data.Equality.Graph.ReprUnionFind.RUF ipv_sd0R ipv1_sd0S ->
                       case break<129>(new_classes_ac9p) new_classes_ac9p of conrep1_ibDI
                       { __DEFAULT ->
                       case (break<131>(new_memo_ac9r) new_memo_ac9r)
                            `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                        <l_acuk>_N <ClassId>_N
                                    :: NodeMap l_acuk ClassId
                                       ~R# Data.Map.Internal.Map (ENode l_acuk) ClassId)
                       of nt1_sd0U
                       { __DEFAULT ->
                       case break<130>(new_worklist_ac9q) new_worklist_ac9q
                       of conrep2_ibDK
                       { __DEFAULT ->
                       Data.Equality.Graph.Internal.EGraph
                         @a_acuj
                         @l_acuk
                         conrep_ibDH
                         conrep1_ibDI
                         (nt1_sd0U
                          `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                           <l_acuk>_N) <ClassId>_N
                                  :: Data.Map.Internal.Map (ENode l_acuk) ClassId
                                     ~R# NodeMap l_acuk ClassId))
                         conrep2_ibDK
                         analysisWorklist_B5
                       }
                       }
                       }
                       }
                       })
                      (break<132>(new_eclass_id_ac9j)
                       AM.modifyA
                         @m_acul @a_acuj @l_acuk $dAnalysisM_acum new_eclass_id_ac9j))
                   (\ (egr1_ac9s :: EGraph a_acuj l_acuk) ->
                      break<134>(new_eclass_id_ac9j,egr1_ac9s)
                      return
                        @m_acul
                        $dMonad_acQc
                        @(ClassId, EGraph a_acuj l_acuk)
                        (new_eclass_id_ac9j, egr1_ac9s)));
          Just canon_enode_id_ac9i ->
            break<106>(egr_ac9g,canon_enode_id_ac9i)
            pure
              @m_acul
              $dApplicative_acuF
              @(ClassId, EGraph a_acuj l_acuk)
              (break<105>(egr_ac9g,canon_enode_id_ac9i)
               (break<31>(canon_enode_id_ac9i)
                . @ReprUnionFind
                  @ClassId
                  @(EGraph a_acuj l_acuk)
                  (break<30>(canon_enode_id_ac9i) findRepr canon_enode_id_ac9i)
                  (unionFind @a_acuj @l_acuk))
                 egr_ac9g,
               egr_ac9g)
        }
        }

-- RHS size: {terms: 71, types: 311, coercions: 21, joins: 0/7}
representM
  :: forall a (l :: * -> *) (m :: * -> *).
     (AM.AnalysisM m a l, Language l) =>
     Fix l -> EGraph a l -> m (ClassId, EGraph a l)
[GblId, Arity=2, Unf=OtherCon []]
representM
  = \ (@a_acwZ)
      (@(l_acx0 :: * -> *))
      (@(m_acx1 :: * -> *))
      ($dAnalysisM_acx2 :: AM.AnalysisM m_acx1 a_acwZ l_acx0)
      ($dLanguage_acx3 :: Language l_acx0) ->
      let {
        $dTraversable_acQr :: Traversable l_acx0
        [LclId]
        $dTraversable_acQr
          = Data.Equality.Language.$p2Language @l_acx0 $dLanguage_acx3 } in
      let {
        $dFunctor_acxc :: Functor l_acx0
        [LclId]
        $dFunctor_acxc
          = Data.Traversable.$p1Traversable @l_acx0 $dTraversable_acQr } in
      let {
        $dMonad_acQm :: Monad m_acx1
        [LclId]
        $dMonad_acQm
          = Data.Equality.Analysis.Monadic.$p1AnalysisM
              @m_acx1 @a_acwZ @l_acx0 $dAnalysisM_acx2 } in
      let {
        $dApplicative_acQn :: Applicative m_acx1
        [LclId]
        $dApplicative_acQn = GHC.Base.$p1Monad @m_acx1 $dMonad_acQm } in
      let {
        $dFunctor1_acQo :: Functor m_acx1
        [LclId]
        $dFunctor1_acQo
          = GHC.Base.$p1Applicative @m_acx1 $dApplicative_acQn } in
      let {
        $dApplicative1_acxD
          :: Applicative (StateT (EGraph a_acwZ l_acx0) m_acx1)
        [LclId]
        $dApplicative1_acxD
          = Control.Monad.Trans.State.Lazy.$fApplicativeStateT
              @m_acx1 @(EGraph a_acwZ l_acx0) $dFunctor1_acQo $dMonad_acQm } in
      let {
        $dMonad1_acxF :: Monad (StateT (EGraph a_acwZ l_acx0) m_acx1)
        [LclId]
        $dMonad1_acxF
          = Control.Monad.Trans.State.Lazy.$fMonadStateT
              @m_acx1 @(EGraph a_acwZ l_acx0) $dMonad_acQm } in
      break<148>()
      $ @ghc-prim:GHC.Types.LiftedRep
        @(l_acx0
            (EGraph a_acwZ l_acx0 -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
          -> EGraph a_acwZ l_acx0 -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
        @(Fix l_acx0
          -> EGraph a_acwZ l_acx0 -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
        (cata
           @l_acx0
           @(EGraph a_acwZ l_acx0 -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
           $dFunctor_acxc)
        (\ (l1_ac9a
              :: l_acx0
                   (EGraph a_acwZ l_acx0 -> m_acx1 (ClassId, EGraph a_acwZ l_acx0)))
           (e_ac9b :: EGraph a_acwZ l_acx0) ->
           break<147>(e_ac9b,l1_ac9a)
           >>=
             @m_acx1
             $dMonad_acQm
             @(l_acx0 ClassId, EGraph a_acwZ l_acx0)
             @(ClassId, EGraph a_acwZ l_acx0)
             (break<144>(e_ac9b,l1_ac9a)
              $ @ghc-prim:GHC.Types.LiftedRep
                @(StateT (EGraph a_acwZ l_acx0) m_acx1 (l_acx0 ClassId))
                @(m_acx1 (l_acx0 ClassId, EGraph a_acwZ l_acx0))
                (break<137>(e_ac9b)
                 \ (v_B2
                      :: StateT (EGraph a_acwZ l_acx0) m_acx1 (l_acx0 ClassId)) ->
                   runStateT
                     @(EGraph a_acwZ l_acx0) @m_acx1 @(l_acx0 ClassId) v_B2 e_ac9b)
                (break<143>(l1_ac9a)
                 traverse
                   @l_acx0
                   $dTraversable_acQr
                   @(StateT (EGraph a_acwZ l_acx0) m_acx1)
                   @(EGraph a_acwZ l_acx0 -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                   @ClassId
                   $dApplicative1_acxD
                   (\ (f_ac9c
                         :: EGraph a_acwZ l_acx0
                            -> m_acx1 (ClassId, EGraph a_acwZ l_acx0)) ->
                      break<142>(f_ac9c)
                      >>=
                        @(StateT (EGraph a_acwZ l_acx0) m_acx1)
                        $dMonad1_acxF
                        @(ClassId, EGraph a_acwZ l_acx0)
                        @ClassId
                        (break<139>(f_ac9c)
                         >>=
                           @(StateT (EGraph a_acwZ l_acx0) m_acx1)
                           $dMonad1_acxF
                           @(EGraph a_acwZ l_acx0)
                           @(ClassId, EGraph a_acwZ l_acx0)
                           (get @m_acx1 @(EGraph a_acwZ l_acx0) $dMonad_acQm)
                           (break<138>(f_ac9c)
                            . @(m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                              @(StateT
                                  (EGraph a_acwZ l_acx0) m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                              @(EGraph a_acwZ l_acx0)
                              (lift
                                 @(StateT (EGraph a_acwZ l_acx0))
                                 (Control.Monad.Trans.State.Lazy.$fMonadTransStateT
                                    @(EGraph a_acwZ l_acx0))
                                 @m_acx1
                                 @(ClassId, EGraph a_acwZ l_acx0)
                                 $dMonad_acQm)
                              f_ac9c))
                        (break<141>()
                         . @(EGraph a_acwZ l_acx0 -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                           @(StateT (EGraph a_acwZ l_acx0) m_acx1 ClassId)
                           @(ClassId, EGraph a_acwZ l_acx0)
                           ((\ (ds_dcVt
                                  :: EGraph a_acwZ l_acx0
                                     -> m_acx1 (ClassId, EGraph a_acwZ l_acx0)) ->
                               ds_dcVt)
                            `cast` (<EGraph a_acwZ l_acx0
                                     -> m_acx1 (ClassId, EGraph a_acwZ l_acx0)>_R
                                    %<Many>_N ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                            <EGraph a_acwZ l_acx0>_N
                                                            <m_acx1>_R
                                                            <ClassId>_N)
                                    :: ((EGraph a_acwZ l_acx0
                                         -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                                        -> EGraph a_acwZ l_acx0
                                        -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                                       ~R# ((EGraph a_acwZ l_acx0
                                             -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                                            -> StateT (EGraph a_acwZ l_acx0) m_acx1 ClassId)))
                           (break<140>()
                            . @(m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                              @(EGraph a_acwZ l_acx0 -> m_acx1 (ClassId, EGraph a_acwZ l_acx0))
                              @(ClassId, EGraph a_acwZ l_acx0)
                              (const
                                 @(m_acx1 (ClassId, EGraph a_acwZ l_acx0)) @(EGraph a_acwZ l_acx0))
                              (pure
                                 @m_acx1 $dApplicative_acQn @(ClassId, EGraph a_acwZ l_acx0)))))
                   l1_ac9a))
             (\ (ds_dcVu :: (l_acx0 ClassId, EGraph a_acwZ l_acx0)) ->
                case ds_dcVu of { (l'_ac9d, e'_ac9e) ->
                break<146>(e'_ac9e,l'_ac9d)
                addM
                  @a_acwZ
                  @l_acx0
                  @m_acx1
                  $dAnalysisM_acx2
                  $dLanguage_acx3
                  ((break<145>(l'_ac9d) l'_ac9d)
                   `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acx0>_R)
                           :: l_acx0 ClassId ~R# ENode l_acx0))
                  e'_ac9e
                }))

-- RHS size: {terms: 275, types: 569, coercions: 4, joins: 0/25}
merge [InlPrag=INLINABLE]
  :: forall a (l :: * -> *).
     (Analysis a l, Language l) =>
     ClassId -> ClassId -> EGraph a l -> (ClassId, EGraph a l)
[GblId, Arity=2, Unf=OtherCon []]
merge
  = \ (@a_acDi)
      (@(l_acDj :: * -> *))
      ($dAnalysis_acDk :: Analysis a_acDi l_acDj)
      ($dLanguage_acDl :: Language l_acDj) ->
      let {
        $dIP_sd0W :: GHC.Stack.Types.CallStack
        [LclId]
        $dIP_sd0W
          = GHC.Stack.Types.pushCallStack
              (ghc-prim:GHC.CString.unpackCString# "assert"#,
               GHC.Stack.Types.SrcLoc
                 (ghc-prim:GHC.CString.unpackCString# "main"#)
                 (ghc-prim:GHC.CString.unpackCString# "Data.Equality.Graph"#)
                 (ghc-prim:GHC.CString.unpackCString#
                    "/home/olivetti/Projects/srtools/srtree/src/Data/Equality/Graph.hs"#)
                 (ghc-prim:GHC.Types.I# 184#)
                 (ghc-prim:GHC.Types.I# 48#)
                 (ghc-prim:GHC.Types.I# 184#)
                 (ghc-prim:GHC.Types.I# 54#))
              GHC.Stack.Types.emptyCallStack } in
      let {
        $dOrd_acR9 :: Ord (l_acDj ClassId)
        [LclId]
        $dOrd_acR9
          = Data.Equality.Language.$p1Language
              @l_acDj $dLanguage_acDl @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dOrd1_acR8 :: Ord (ENode l_acDj)
        [LclId]
        $dOrd1_acR8
          = Data.Equality.Graph.Nodes.$fOrdENode @l_acDj $dOrd_acR9 } in
      let {
        $dSemigroup_acG6 :: Semigroup (S.Set (ENode l_acDj))
        [LclId]
        $dSemigroup_acG6
          = Data.Set.Internal.$fSemigroupSet @(ENode l_acDj) $dOrd1_acR8 } in
      let {
        $dEq_acR1 :: Eq a_acDi
        [LclId]
        $dEq_acR1
          = Data.Equality.Analysis.$p1Analysis
              @a_acDi @l_acDj $dAnalysis_acDk } in
      \ (a1_ac8m :: ClassId)
        (b_ac8n :: ClassId)
        (egr0_ac8o :: EGraph a_acDi l_acDj) ->
        let {
          b'_ac8q :: ClassId
          [LclId]
          b'_ac8q
            = break<192>(b_ac8n,egr0_ac8o)
              (break<31>(b_ac8n)
               . @ReprUnionFind
                 @ClassId
                 @(EGraph a_acDi l_acDj)
                 (break<30>(b_ac8n) findRepr b_ac8n)
                 (unionFind @a_acDi @l_acDj))
                egr0_ac8o } in
        let {
          a'_ac8p :: ClassId
          [LclId]
          a'_ac8p
            = break<193>(a1_ac8m,egr0_ac8o)
              (break<31>(a1_ac8m)
               . @ReprUnionFind
                 @ClassId
                 @(EGraph a_acDi l_acDj)
                 (break<30>(a1_ac8m) findRepr a1_ac8m)
                 (unionFind @a_acDi @l_acDj))
                egr0_ac8o } in
        break<248>(a'_ac8p,b'_ac8q,egr0_ac8o)
        case break<194>(a'_ac8p,b'_ac8q)
             == @ClassId ghc-prim:GHC.Classes.$fEqInt a'_ac8p b'_ac8q
        of {
          False ->
            let {
              class_b_ac8s :: EClass a_acDi l_acDj
              [LclId]
              class_b_ac8s
                = break<195>(b'_ac8q,egr0_ac8o)
                  ^.
                    @(EGraph a_acDi l_acDj)
                    @(EClass a_acDi l_acDj)
                    egr0_ac8o
                    (\ (@(f_acDB :: * -> *)) ($dFunctor_acDC :: Functor f_acDB) ->
                       _class @a_acDi @l_acDj b'_ac8q @f_acDB $dFunctor_acDC) } in
            let {
              class_a_ac8r :: EClass a_acDi l_acDj
              [LclId]
              class_a_ac8r
                = break<196>(a'_ac8p,egr0_ac8o)
                  ^.
                    @(EGraph a_acDi l_acDj)
                    @(EClass a_acDi l_acDj)
                    egr0_ac8o
                    (\ (@(f_acDP :: * -> *)) ($dFunctor_acDQ :: Functor f_acDP) ->
                       _class @a_acDi @l_acDj a'_ac8p @f_acDP $dFunctor_acDQ) } in
            let {
              ds_dcXN
                :: (ClassId, EClass a_acDi l_acDj, ClassId, EClass a_acDi l_acDj)
              [LclId]
              ds_dcXN
                = break<202>(a'_ac8p,b'_ac8q,class_a_ac8r,class_b_ac8s)
                  case break<201>(class_a_ac8r,class_b_ac8s)
                       < @Int
                         ghc-prim:GHC.Classes.$fOrdInt
                         (break<198>(class_a_ac8r)
                          sizeSL
                            @(ClassId, ENode l_acDj)
                            (break<197>(class_a_ac8r)
                             ^.
                               @(EClass a_acDi l_acDj)
                               @(SList (ClassId, ENode l_acDj))
                               class_a_ac8r
                               (_parents @a_acDi @l_acDj)))
                         (break<200>(class_b_ac8s)
                          sizeSL
                            @(ClassId, ENode l_acDj)
                            (break<199>(class_b_ac8s)
                             ^.
                               @(EClass a_acDi l_acDj)
                               @(SList (ClassId, ENode l_acDj))
                               class_b_ac8s
                               (_parents @a_acDi @l_acDj)))
                  of {
                    False -> (a'_ac8p, class_a_ac8r, b'_ac8q, class_b_ac8s);
                    True -> (b'_ac8q, class_b_ac8s, a'_ac8p, class_a_ac8r)
                  } } in
            let {
              leader_ac8t :: ClassId
              [LclId]
              leader_ac8t
                = case ds_dcXN of
                  { (leader1_X3, leader_class_ac8u, sub_ac8v, sub_class_ac8w) ->
                  leader1_X3
                  } } in
            let {
              leader_class_ac8u :: EClass a_acDi l_acDj
              [LclId]
              leader_class_ac8u
                = case ds_dcXN of
                  { (leader1_X3, leader_class1_X4, sub_ac8v, sub_class_ac8w) ->
                  leader_class1_X4
                  } } in
            let {
              sub_ac8v :: ClassId
              [LclId]
              sub_ac8v
                = case ds_dcXN of
                  { (leader1_X3, leader_class1_X4, sub1_X5, sub_class_ac8w) ->
                  sub1_X5
                  } } in
            let {
              sub_class_ac8w :: EClass a_acDi l_acDj
              [LclId]
              sub_class_ac8w
                = case ds_dcXN of
                  { (leader1_X3, leader_class1_X4, sub1_X5, sub_class1_X6) ->
                  sub_class1_X6
                  } } in
            let {
              ds1_dcXM :: (ClassId, ReprUnionFind)
              [LclId]
              ds1_dcXM
                = break<208>(egr0_ac8o,leader_ac8t,sub_ac8v)
                  & @(ClassId, ReprUnionFind)
                    @(ClassId, ReprUnionFind)
                    (break<204>(egr0_ac8o,leader_ac8t,sub_ac8v)
                     unionSets
                       leader_ac8t
                       sub_ac8v
                       (break<203>(egr0_ac8o) unionFind @a_acDi @l_acDj egr0_ac8o))
                    (break<207>(leader_ac8t)
                     first
                       @(,)
                       Data.Bifunctor.$fBifunctor(,)
                       @ClassId
                       @ClassId
                       @ReprUnionFind
                       (\ (n_ac8F :: ClassId) ->
                          break<206>(n_ac8F,leader_ac8t)
                          GHC.IO.Exception.assertError
                            @ClassId
                            ($dIP_sd0W
                             `cast` (Sym (ghc-prim:GHC.Classes.N:IP[0]
                                              <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                     :: GHC.Stack.Types.CallStack
                                        ~R# (?callStack::GHC.Stack.Types.CallStack)))
                            (break<205>(n_ac8F,leader_ac8t)
                             == @ClassId ghc-prim:GHC.Classes.$fEqInt leader_ac8t n_ac8F)
                            n_ac8F)) } in
            let {
              new_id_ac8x :: ClassId
              [LclId]
              new_id_ac8x
                = case ds1_dcXM of { (new_id1_X3, new_uf_ac8y) -> new_id1_X3 } } in
            let {
              new_uf_ac8y :: ReprUnionFind
              [LclId]
              new_uf_ac8y
                = case ds1_dcXM of { (new_id1_X3, new_uf1_X4) -> new_uf1_X4 } } in
            let {
              new_data_ac8A :: a_acDi
              [LclId]
              new_data_ac8A
                = break<211>(leader_class_ac8u,sub_class_ac8w)
                  joinA
                    @a_acDi
                    @l_acDj
                    $dAnalysis_acDk
                    (break<209>(leader_class_ac8u)
                     ^.
                       @(EClass a_acDi l_acDj)
                       @a_acDi
                       leader_class_ac8u
                       (_data @a_acDi @l_acDj @a_acDi))
                    (break<210>(sub_class_ac8w)
                     ^.
                       @(EClass a_acDi l_acDj)
                       @a_acDi
                       sub_class_ac8w
                       (_data @a_acDi @l_acDj @a_acDi)) } in
            let {
              updatedLeader_ac8z :: EClass a_acDi l_acDj
              [LclId]
              updatedLeader_ac8z
                = break<221>(leader_class_ac8u,sub_class_ac8w,new_data_ac8A)
                  & @(EClass a_acDi l_acDj)
                    @(EClass a_acDi l_acDj)
                    (break<219>(leader_class_ac8u,sub_class_ac8w)
                     & @(EClass a_acDi l_acDj)
                       @(EClass a_acDi l_acDj)
                       (break<215>(leader_class_ac8u,sub_class_ac8w)
                        & @(EClass a_acDi l_acDj)
                          @(EClass a_acDi l_acDj)
                          leader_class_ac8u
                          (break<214>(sub_class_ac8w)
                           %~
                             @(EClass a_acDi l_acDj)
                             @(EClass a_acDi l_acDj)
                             @(SList (ClassId, ENode l_acDj))
                             @(SList (ClassId, ENode l_acDj))
                             (_parents
                                @a_acDi
                                @l_acDj
                                @Data.Functor.Identity.Identity
                                Data.Functor.Identity.$fFunctorIdentity)
                             (break<213>(sub_class_ac8w)
                              let {
                                v_B1
                                  :: SList (ClassId, ENode l_acDj) -> SList (ClassId, ENode l_acDj)
                                [LclId]
                                v_B1
                                  = <>
                                      @(SList (ClassId, ENode l_acDj))
                                      (Data.Equality.Utils.SizedList.$fSemigroupSList
                                         @(ClassId, ENode l_acDj))
                                      (break<212>(sub_class_ac8w)
                                       ^.
                                         @(EClass a_acDi l_acDj)
                                         @(SList (ClassId, ENode l_acDj))
                                         sub_class_ac8w
                                         (_parents @a_acDi @l_acDj)) } in
                              \ (v1_B2 :: SList (ClassId, ENode l_acDj)) -> v_B1 v1_B2)))
                       (break<218>(sub_class_ac8w)
                        %~
                          @(EClass a_acDi l_acDj)
                          @(EClass a_acDi l_acDj)
                          @(S.Set (ENode l_acDj))
                          @(S.Set (ENode l_acDj))
                          (_nodes
                             @a_acDi
                             @l_acDj
                             @Data.Functor.Identity.Identity
                             Data.Functor.Identity.$fFunctorIdentity)
                          (break<217>(sub_class_ac8w)
                           let {
                             v_B1 :: S.Set (ENode l_acDj) -> S.Set (ENode l_acDj)
                             [LclId]
                             v_B1
                               = <>
                                   @(S.Set (ENode l_acDj))
                                   $dSemigroup_acG6
                                   (break<216>(sub_class_ac8w)
                                    ^.
                                      @(EClass a_acDi l_acDj)
                                      @(S.Set (ENode l_acDj))
                                      sub_class_ac8w
                                      (_nodes @a_acDi @l_acDj)) } in
                           \ (v1_B2 :: S.Set (ENode l_acDj)) -> v_B1 v1_B2)))
                    (break<220>(new_data_ac8A)
                     .~
                       @(EClass a_acDi l_acDj)
                       @a_acDi
                       (_data @a_acDi @l_acDj @a_acDi)
                       new_data_ac8A) } in
            let {
              new_classes_ac8B :: IM.IntMap (EClass a_acDi l_acDj)
              [LclId]
              new_classes_ac8B
                = break<225>(egr0_ac8o,leader_ac8t,sub_ac8v,updatedLeader_ac8z)
                  . @(IM.IntMap (EClass a_acDi l_acDj))
                    @(IM.IntMap (EClass a_acDi l_acDj))
                    @(IM.IntMap (EClass a_acDi l_acDj))
                    (break<222>(leader_ac8t,updatedLeader_ac8z)
                     IM.insert @(EClass a_acDi l_acDj) leader_ac8t updatedLeader_ac8z)
                    (break<223>(sub_ac8v) IM.delete @(EClass a_acDi l_acDj) sub_ac8v)
                    (break<224>(egr0_ac8o) classes @a_acDi @l_acDj egr0_ac8o) } in
            let {
              new_worklist_ac8C :: [(ClassId, ENode l_acDj)]
              [LclId]
              new_worklist_ac8C
                = break<229>(egr0_ac8o,sub_class_ac8w)
                  <>
                    @[(ClassId, ENode l_acDj)]
                    (GHC.Base.$fSemigroupList @(ClassId, ENode l_acDj))
                    (break<227>(sub_class_ac8w)
                     toListSL
                       @(ClassId, ENode l_acDj)
                       (break<226>(sub_class_ac8w)
                        ^.
                          @(EClass a_acDi l_acDj)
                          @(SList (ClassId, ENode l_acDj))
                          sub_class_ac8w
                          (_parents @a_acDi @l_acDj)))
                    (break<228>(egr0_ac8o) worklist @a_acDi @l_acDj egr0_ac8o) } in
            let {
              new_analysis_worklist_ac8D :: [(ClassId, ENode l_acDj)]
              [LclId]
              new_analysis_worklist_ac8D
                = break<240>(egr0_ac8o,leader_class_ac8u,sub_class_ac8w,new_data_ac8A)
                  <>
                    @[(ClassId, ENode l_acDj)]
                    (GHC.Base.$fSemigroupList @(ClassId, ENode l_acDj))
                    (case break<231>(sub_class_ac8w,new_data_ac8A)
                          /=
                            @a_acDi
                            $dEq_acR1
                            new_data_ac8A
                            (break<230>(sub_class_ac8w)
                             ^.
                               @(EClass a_acDi l_acDj)
                               @a_acDi
                               sub_class_ac8w
                               (_data @a_acDi @l_acDj @a_acDi))
                     of {
                       False ->
                         mempty
                           @[(ClassId, ENode l_acDj)]
                           (GHC.Base.$fMonoidList @(ClassId, ENode l_acDj));
                       True ->
                         break<233>(sub_class_ac8w)
                         toListSL
                           @(ClassId, ENode l_acDj)
                           (break<232>(sub_class_ac8w)
                            ^.
                              @(EClass a_acDi l_acDj)
                              @(SList (ClassId, ENode l_acDj))
                              sub_class_ac8w
                              (_parents @a_acDi @l_acDj))
                     })
                    (break<239>(egr0_ac8o,leader_class_ac8u,new_data_ac8A)
                     <>
                       @[(ClassId, ENode l_acDj)]
                       (GHC.Base.$fSemigroupList @(ClassId, ENode l_acDj))
                       (case break<235>(leader_class_ac8u,new_data_ac8A)
                             /=
                               @a_acDi
                               $dEq_acR1
                               new_data_ac8A
                               (break<234>(leader_class_ac8u)
                                ^.
                                  @(EClass a_acDi l_acDj)
                                  @a_acDi
                                  leader_class_ac8u
                                  (_data @a_acDi @l_acDj @a_acDi))
                        of {
                          False ->
                            mempty
                              @[(ClassId, ENode l_acDj)]
                              (GHC.Base.$fMonoidList @(ClassId, ENode l_acDj));
                          True ->
                            break<237>(leader_class_ac8u)
                            toListSL
                              @(ClassId, ENode l_acDj)
                              (break<236>(leader_class_ac8u)
                               ^.
                                 @(EClass a_acDi l_acDj)
                                 @(SList (ClassId, ENode l_acDj))
                                 leader_class_ac8u
                                 (_parents @a_acDi @l_acDj))
                        })
                       (break<238>(egr0_ac8o)
                        analysisWorklist @a_acDi @l_acDj egr0_ac8o)) } in
            let {
              egr1_ac8E :: EGraph a_acDi l_acDj
              [LclId]
              egr1_ac8E
                = break<246>(new_uf_ac8y,new_classes_ac8B,new_worklist_ac8C,egr0_ac8o,new_id_ac8x,new_analysis_worklist_ac8D)
                  & @(EGraph a_acDi l_acDj)
                    @(EGraph a_acDi l_acDj)
                    (case egr0_ac8o of
                     { EGraph ds2_dcXI ds3_dcXJ memo_B3 ds4_dcXK ds5_dcXL ->
                     case break<241>(new_uf_ac8y) new_uf_ac8y of conrep_ibDH
                     { Data.Equality.Graph.ReprUnionFind.RUF ipv_sd0X ipv1_sd0Y ->
                     case break<242>(new_classes_ac8B) new_classes_ac8B of conrep1_ibDI
                     { __DEFAULT ->
                     case break<243>(new_worklist_ac8C) new_worklist_ac8C
                     of conrep2_ibDK
                     { __DEFAULT ->
                     case break<244>(new_analysis_worklist_ac8D)
                          new_analysis_worklist_ac8D
                     of conrep3_ibDL
                     { __DEFAULT ->
                     Data.Equality.Graph.Internal.EGraph
                       @a_acDi
                       @l_acDj
                       conrep_ibDH
                       conrep1_ibDI
                       memo_B3
                       conrep2_ibDK
                       conrep3_ibDL
                     }
                     }
                     }
                     }
                     })
                    (break<245>(new_id_ac8x)
                     modifyA @a_acDi @l_acDj $dAnalysis_acDk new_id_ac8x) } in
            break<247>(new_id_ac8x,egr1_ac8E) (new_id_ac8x, egr1_ac8E);
          True -> (a'_ac8p, egr0_ac8o)
        }

-- RHS size: {terms: 55, types: 91, coercions: 14, joins: 0/1}
repair [InlPrag=INLINE (sat-args=2)]
  :: forall a (l :: * -> *).
     (Analysis a l, Language l) =>
     (ClassId, ENode l) -> EGraph a l -> EGraph a l
[GblId, Arity=2, Unf=OtherCon []]
repair
  = \ (@a_acIx)
      (@(l_acIy :: * -> *))
      ($dAnalysis_acIz :: Analysis a_acIx l_acIy)
      ($dLanguage_acIA :: Language l_acIy) ->
      let {
        $dOrd_acIG :: Ord (l_acIy ClassId)
        [LclId]
        $dOrd_acIG
          = Data.Equality.Language.$p1Language
              @l_acIy $dLanguage_acIA @Int ghc-prim:GHC.Classes.$fOrdInt } in
      \ (ds_dcXO :: (ClassId, ENode l_acIy))
        (egr_ac8S :: EGraph a_acIx l_acIy) ->
        case ds_dcXO of { (repair_id_ac8Q, node_ac8R) ->
        break<256>(egr_ac8S,repair_id_ac8Q,node_ac8R)
        case break<250>(egr_ac8S,repair_id_ac8Q,node_ac8R)
             insertLookupNM
               @l_acIy
               @ClassId
               $dOrd_acIG
               node_ac8R
               repair_id_ac8Q
               (break<249>(egr_ac8S) memo @a_acIx @l_acIy egr_ac8S)
        of
        { (ds1_dcYh, memo'_ac8T) ->
        case ds1_dcYh of {
          Nothing ->
            break<252>(egr_ac8S,memo'_ac8T)
            case egr_ac8S of
            { EGraph unionFind_B1 classes_B2 ds2_dcY9 worklist_B4
                     analysisWorklist_B5 ->
            case (break<251>(memo'_ac8T) memo'_ac8T)
                 `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                             <l_acIy>_N <ClassId>_N
                         :: NodeMap l_acIy ClassId
                            ~R# Data.Map.Internal.Map (ENode l_acIy) ClassId)
            of nt_sd11
            { __DEFAULT ->
            Data.Equality.Graph.Internal.EGraph
              @a_acIx
              @l_acIy
              unionFind_B1
              classes_B2
              (nt_sd11
               `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                <l_acIy>_N) <ClassId>_N
                       :: Data.Map.Internal.Map (ENode l_acIy) ClassId
                          ~R# NodeMap l_acIy ClassId))
              worklist_B4
              analysisWorklist_B5
            }
            };
          Just existing_class_ac8U ->
            break<255>(egr_ac8S,repair_id_ac8Q,memo'_ac8T,existing_class_ac8U)
            snd
              @ClassId
              @(EGraph a_acIx l_acIy)
              (break<254>(egr_ac8S,repair_id_ac8Q,memo'_ac8T,existing_class_ac8U)
               merge
                 @a_acIx
                 @l_acIy
                 $dAnalysis_acIz
                 $dLanguage_acIA
                 existing_class_ac8U
                 repair_id_ac8Q
                 (case egr_ac8S of
                  { EGraph unionFind_B1 classes_B2 ds2_dcYg worklist_B4
                           analysisWorklist_B5 ->
                  case (break<253>(memo'_ac8T) memo'_ac8T)
                       `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                   <l_acIy>_N <ClassId>_N
                               :: NodeMap l_acIy ClassId
                                  ~R# Data.Map.Internal.Map (ENode l_acIy) ClassId)
                  of nt_sd12
                  { __DEFAULT ->
                  Data.Equality.Graph.Internal.EGraph
                    @a_acIx
                    @l_acIy
                    unionFind_B1
                    classes_B2
                    (nt_sd12
                     `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                      <l_acIy>_N) <ClassId>_N
                             :: Data.Map.Internal.Map (ENode l_acIy) ClassId
                                ~R# NodeMap l_acIy ClassId))
                    worklist_B4
                    analysisWorklist_B5
                  }
                  }))
        }
        }
        }

Rec {
-- RHS size: {terms: 247, types: 450, coercions: 23, joins: 0/16}
rebuild [InlPrag=INLINABLE, Occ=LoopBreaker]
  :: forall a (l :: * -> *).
     (Analysis a l, Language l) =>
     EGraph a l -> EGraph a l
[GblId, Arity=2, Unf=OtherCon []]
rebuild
  = \ (@a_acJr)
      (@(l_acJs :: * -> *))
      ($dAnalysis_acJt :: Analysis a_acJr l_acJs)
      ($dLanguage_acJu :: Language l_acJs) ->
      let {
        $dFunctor_sd13 :: Traversable l_acJs
        [LclId]
        $dFunctor_sd13
          = Data.Equality.Language.$p2Language @l_acJs $dLanguage_acJu } in
      let {
        $dFunctor1_acKl :: Functor l_acJs
        [LclId]
        $dFunctor1_acKl
          = Data.Traversable.$p1Traversable @l_acJs $dFunctor_sd13 } in
      let {
        $dOrd_acRz :: Ord (l_acJs ClassId)
        [LclId]
        $dOrd_acRz
          = Data.Equality.Language.$p1Language
              @l_acJs $dLanguage_acJu @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dOrd1_acRy :: Ord (ENode l_acJs)
        [LclId]
        $dOrd1_acRy
          = Data.Equality.Graph.Nodes.$fOrdENode @l_acJs $dOrd_acRz } in
      let {
        $dOrd2_acJQ :: Ord (ClassId, ENode l_acJs)
        [LclId]
        $dOrd2_acJQ
          = ghc-prim:GHC.Classes.$fOrd(,)
              @Int @(ENode l_acJs) ghc-prim:GHC.Classes.$fOrdInt $dOrd1_acRy } in
      \ (ds_dcYi :: EGraph a_acJr l_acJs) ->
        case ds_dcYi of
        { EGraph uf_ac8G cls_ac8H mm_ac8I wl_ac8J awl_ac8K ->
        let {
          emptiedEgr_ac8L :: EGraph a_acJr l_acJs
          [LclId]
          emptiedEgr_ac8L
            = break<257>(cls_ac8H,uf_ac8G,mm_ac8I)
              case mempty
                     @(Worklist l_acJs) (GHC.Base.$fMonoidList @(ClassId, ENode l_acJs))
              of conrep_ibDK
              { __DEFAULT ->
              case mempty
                     @(Worklist l_acJs) (GHC.Base.$fMonoidList @(ClassId, ENode l_acJs))
              of conrep1_ibDL
              { __DEFAULT ->
              Data.Equality.Graph.Internal.EGraph
                @a_acJr @l_acJs uf_ac8G cls_ac8H mm_ac8I conrep_ibDK conrep1_ibDL
              }
              } } in
        let {
          wl'_ac8M :: [(ClassId, ENode l_acJs)]
          [LclId]
          wl'_ac8M
            = break<262>(wl_ac8J,emptiedEgr_ac8L)
              $ @ghc-prim:GHC.Types.LiftedRep
                @[(ClassId, ENode l_acJs)]
                @[(ClassId, ENode l_acJs)]
                (nubOrd @(ClassId, ENode l_acJs) $dOrd2_acJQ)
                (break<261>(wl_ac8J,emptiedEgr_ac8L)
                 <$>
                   @[]
                   @(ClassId, ENode l_acJs)
                   @(ClassId, ENode l_acJs)
                   GHC.Base.$fFunctorList
                   (break<260>(emptiedEgr_ac8L)
                    bimap
                      @(,)
                      Data.Bifunctor.$fBifunctor(,)
                      @ClassId
                      @ClassId
                      @(ENode l_acJs)
                      @(ENode l_acJs)
                      (break<258>(emptiedEgr_ac8L)
                       \ (v_B2 :: ClassId) ->
                         (break<31>(v_B2)
                          . @ReprUnionFind
                            @ClassId
                            @(EGraph a_acJr l_acJs)
                            (break<30>(v_B2) findRepr v_B2)
                            (unionFind @a_acJr @l_acJs))
                           emptiedEgr_ac8L)
                      (break<259>(emptiedEgr_ac8L)
                       \ (v_B2 :: ENode l_acJs) ->
                         break<101>(v_B2,emptiedEgr_ac8L)
                         $ @ghc-prim:GHC.Types.LiftedRep
                           @(l_acJs ClassId)
                           @(ENode l_acJs)
                           ((\ (ds1_dcUI :: l_acJs ClassId) -> ds1_dcUI)
                            `cast` (<l_acJs ClassId>_R
                                    %<Many>_N ->_R Sym (Data.Equality.Graph.Nodes.N:ENode[0]
                                                            <l_acJs>_R)
                                    :: (l_acJs ClassId -> l_acJs ClassId)
                                       ~R# (l_acJs ClassId -> ENode l_acJs)))
                           (break<100>(v_B2,emptiedEgr_ac8L)
                            fmap
                              @l_acJs
                              $dFunctor1_acKl
                              @ClassId
                              @ClassId
                              (break<99>(emptiedEgr_ac8L)
                               \ (v1_X2 :: ClassId) ->
                                 (break<31>(v1_X2)
                                  . @ReprUnionFind
                                    @ClassId
                                    @(EGraph a_acJr l_acJs)
                                    (break<30>(v1_X2) findRepr v1_X2)
                                    (unionFind @a_acJr @l_acJs))
                                   emptiedEgr_ac8L)
                              (v_B2
                               `cast` (Data.Equality.Graph.Nodes.N:ENode[0] <l_acJs>_R
                                       :: ENode l_acJs ~R# l_acJs ClassId)))))
                   wl_ac8J) } in
        let {
          egr'_ac8N :: EGraph a_acJr l_acJs
          [LclId]
          egr'_ac8N
            = break<263>(emptiedEgr_ac8L,wl'_ac8M)
              foldr
                @[]
                Data.Foldable.$fFoldableList
                @(ClassId, ENode l_acJs)
                @(EGraph a_acJr l_acJs)
                (let {
                   $dOrd3_acIG :: Ord (l_acJs ClassId)
                   [LclId]
                   $dOrd3_acIG
                     = Data.Equality.Language.$p1Language
                         @l_acJs $dLanguage_acJu @Int ghc-prim:GHC.Classes.$fOrdInt } in
                 \ (ds1_dcXO :: (ClassId, ENode l_acJs))
                   (egr_ac8S :: EGraph a_acJr l_acJs) ->
                   case ds1_dcXO of { (repair_id_ac8Q, node_ac8R) ->
                   break<256>(egr_ac8S,repair_id_ac8Q,node_ac8R)
                   case break<250>(egr_ac8S,repair_id_ac8Q,node_ac8R)
                        insertLookupNM
                          @l_acJs
                          @ClassId
                          $dOrd3_acIG
                          node_ac8R
                          repair_id_ac8Q
                          (break<249>(egr_ac8S) memo @a_acJr @l_acJs egr_ac8S)
                   of
                   { (ds2_dcYh, memo'_ac8T) ->
                   case ds2_dcYh of {
                     Nothing ->
                       break<252>(egr_ac8S,memo'_ac8T)
                       case egr_ac8S of
                       { EGraph unionFind_B1 classes_B2 ds3_dcY9 worklist_B4
                                analysisWorklist_B5 ->
                       case (break<251>(memo'_ac8T) memo'_ac8T)
                            `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                        <l_acJs>_N <ClassId>_N
                                    :: NodeMap l_acJs ClassId
                                       ~R# Data.Map.Internal.Map (ENode l_acJs) ClassId)
                       of nt_sd14
                       { __DEFAULT ->
                       Data.Equality.Graph.Internal.EGraph
                         @a_acJr
                         @l_acJs
                         unionFind_B1
                         classes_B2
                         (nt_sd14
                          `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                           <l_acJs>_N) <ClassId>_N
                                  :: Data.Map.Internal.Map (ENode l_acJs) ClassId
                                     ~R# NodeMap l_acJs ClassId))
                         worklist_B4
                         analysisWorklist_B5
                       }
                       };
                     Just existing_class_ac8U ->
                       break<255>(egr_ac8S,repair_id_ac8Q,memo'_ac8T,existing_class_ac8U)
                       snd
                         @ClassId
                         @(EGraph a_acJr l_acJs)
                         (break<254>(egr_ac8S,repair_id_ac8Q,memo'_ac8T,existing_class_ac8U)
                          merge
                            @a_acJr
                            @l_acJs
                            $dAnalysis_acJt
                            $dLanguage_acJu
                            existing_class_ac8U
                            repair_id_ac8Q
                            (case egr_ac8S of
                             { EGraph unionFind_B1 classes_B2 ds3_dcYg worklist_B4
                                      analysisWorklist_B5 ->
                             case (break<253>(memo'_ac8T) memo'_ac8T)
                                  `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                              <l_acJs>_N <ClassId>_N
                                          :: NodeMap l_acJs ClassId
                                             ~R# Data.Map.Internal.Map (ENode l_acJs) ClassId)
                             of nt_sd15
                             { __DEFAULT ->
                             Data.Equality.Graph.Internal.EGraph
                               @a_acJr
                               @l_acJs
                               unionFind_B1
                               classes_B2
                               (nt_sd15
                                `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                                 <l_acJs>_N) <ClassId>_N
                                        :: Data.Map.Internal.Map (ENode l_acJs) ClassId
                                           ~R# NodeMap l_acJs ClassId))
                               worklist_B4
                               analysisWorklist_B5
                             }
                             }))
                   }
                   }
                   })
                emptiedEgr_ac8L
                wl'_ac8M } in
        let {
          awl'_ac8O :: [(Int, ENode l_acJs)]
          [LclId]
          awl'_ac8O
            = break<268>(awl_ac8K,egr'_ac8N)
              $ @ghc-prim:GHC.Types.LiftedRep
                @[(Int, ENode l_acJs)]
                @[(Int, ENode l_acJs)]
                (break<264>()
                 nubIntOn @(Int, ENode l_acJs) (fst @Int @(ENode l_acJs)))
                (break<267>(awl_ac8K,egr'_ac8N)
                 <$>
                   @[]
                   @(ClassId, ENode l_acJs)
                   @(Int, ENode l_acJs)
                   GHC.Base.$fFunctorList
                   (break<266>(egr'_ac8N)
                    first
                      @(,)
                      Data.Bifunctor.$fBifunctor(,)
                      @ClassId
                      @Int
                      @(ENode l_acJs)
                      (break<265>(egr'_ac8N)
                       \ (v_B2 :: ClassId) ->
                         (break<31>(v_B2)
                          . @ReprUnionFind
                            @ClassId
                            @(EGraph a_acJr l_acJs)
                            (break<30>(v_B2) findRepr v_B2)
                            (unionFind @a_acJr @l_acJs))
                           egr'_ac8N))
                   awl_ac8K) } in
        let {
          egr''_ac8P :: EGraph a_acJr l_acJs
          [LclId]
          egr''_ac8P
            = break<269>(egr'_ac8N,awl'_ac8O)
              foldr
                @[]
                Data.Foldable.$fFoldableList
                @(ClassId, ENode l_acJs)
                @(EGraph a_acJr l_acJs)
                (\ (eta_B0 :: (ClassId, ENode l_acJs))
                   (eta1_B1 :: EGraph a_acJr l_acJs) ->
                   let {
                     $dFunctor2_sd0B :: Traversable l_acJs
                     [LclId]
                     $dFunctor2_sd0B
                       = Data.Equality.Language.$p2Language @l_acJs $dLanguage_acJu } in
                   let {
                     $dFunctor3_acBD :: Functor l_acJs
                     [LclId]
                     $dFunctor3_acBD
                       = Data.Traversable.$p1Traversable @l_acJs $dFunctor2_sd0B } in
                   let {
                     $dEq_acC6 :: Eq a_acJr
                     [LclId]
                     $dEq_acC6
                       = Data.Equality.Analysis.$p1Analysis
                           @a_acJr @l_acJs $dAnalysis_acJt } in
                   case eta_B0 of { (repair_id_ac8W, node_ac8X) ->
                   let {
                     c_ac8Z :: EClass a_acJr l_acJs
                     [LclId]
                     c_ac8Z
                       = break<172>(eta1_B1,repair_id_ac8W)
                         ^.
                           @(EGraph a_acJr l_acJs)
                           @(EClass a_acJr l_acJs)
                           eta1_B1
                           (\ (@(f_acB5 :: * -> *)) ($dFunctor4_acB6 :: Functor f_acB5) ->
                              _class @a_acJr @l_acJs repair_id_ac8W @f_acB5 $dFunctor4_acB6) } in
                   let {
                     new_data_ac90 :: a_acJr
                     [LclId]
                     new_data_ac90
                       = break<179>(c_ac8Z,eta1_B1,node_ac8X)
                         joinA
                           @a_acJr
                           @l_acJs
                           $dAnalysis_acJt
                           (break<173>(c_ac8Z)
                            ^.
                              @(EClass a_acJr l_acJs)
                              @a_acJr
                              c_ac8Z
                              (_data @a_acJr @l_acJs @a_acJr))
                           (break<178>(eta1_B1,node_ac8X)
                            makeA
                              @a_acJr
                              @l_acJs
                              $dAnalysis_acJt
                              (break<177>(eta1_B1,node_ac8X)
                               <$>
                                 @l_acJs
                                 @ClassId
                                 @a_acJr
                                 $dFunctor3_acBD
                                 (\ (i_ac91 :: ClassId) ->
                                    break<175>(i_ac91,eta1_B1)
                                    ^.
                                      @(EClass a_acJr l_acJs)
                                      @a_acJr
                                      (break<174>(i_ac91,eta1_B1)
                                       ^.
                                         @(EGraph a_acJr l_acJs)
                                         @(EClass a_acJr l_acJs)
                                         eta1_B1
                                         (\ (@(f_acBI :: * -> *))
                                            ($dFunctor4_acBJ :: Functor f_acBI) ->
                                            _class @a_acJr @l_acJs i_ac91 @f_acBI $dFunctor4_acBJ))
                                      (_data @a_acJr @l_acJs @a_acJr))
                                 (break<176>(node_ac8X) unNode @l_acJs node_ac8X))) } in
                   break<191>(c_ac8Z,eta1_B1,new_data_ac90,repair_id_ac8W)
                   case break<181>(c_ac8Z,new_data_ac90)
                        /=
                          @a_acJr
                          $dEq_acC6
                          (break<180>(c_ac8Z)
                           ^.
                             @(EClass a_acJr l_acJs)
                             @a_acJr
                             c_ac8Z
                             (_data @a_acJr @l_acJs @a_acJr))
                          new_data_ac90
                   of {
                     False -> eta1_B1;
                     True ->
                       break<190>(c_ac8Z,eta1_B1,new_data_ac90,repair_id_ac8W)
                       & @(EGraph a_acJr l_acJs)
                         @(EGraph a_acJr l_acJs)
                         (case eta1_B1 of wild3_X4
                          { EGraph unionFind_X5 ds1_dcXr memo_B3 worklist_B4 ds2_dcXs ->
                          case break<188>(eta1_B1,new_data_ac90,repair_id_ac8W)
                               IM.adjust
                                 @(EClass a_acJr l_acJs)
                                 (break<186>(new_data_ac90)
                                  .~
                                    @(EClass a_acJr l_acJs)
                                    @a_acJr
                                    (_data @a_acJr @l_acJs @a_acJr)
                                    new_data_ac90)
                                 repair_id_ac8W
                                 (break<187>(eta1_B1) classes @a_acJr @l_acJs wild3_X4)
                          of conrep_ibDI
                          { __DEFAULT ->
                          case break<185>(c_ac8Z,eta1_B1)
                               <>
                                 @(Worklist l_acJs)
                                 (GHC.Base.$fSemigroupList @(ClassId, ENode l_acJs))
                                 (break<183>(c_ac8Z)
                                  toListSL
                                    @(ClassId, ENode l_acJs)
                                    (break<182>(c_ac8Z)
                                     ^.
                                       @(EClass a_acJr l_acJs)
                                       @(SList (ClassId, ENode l_acJs))
                                       c_ac8Z
                                       (_parents @a_acJr @l_acJs)))
                                 (break<184>(eta1_B1) analysisWorklist @a_acJr @l_acJs wild3_X4)
                          of conrep1_ibDL
                          { __DEFAULT ->
                          Data.Equality.Graph.Internal.EGraph
                            @a_acJr
                            @l_acJs
                            unionFind_X5
                            conrep_ibDI
                            memo_B3
                            worklist_B4
                            conrep1_ibDL
                          }
                          }
                          })
                         (break<189>(repair_id_ac8W)
                          modifyA @a_acJr @l_acJs $dAnalysis_acJt repair_id_ac8W)
                   }
                   })
                egr'_ac8N
                awl'_ac8O } in
        break<276>(egr''_ac8P)
        case break<274>(egr''_ac8P)
             &&
               (break<271>(egr''_ac8P)
                null
                  @[]
                  Data.Foldable.$fFoldableList
                  @(ClassId, ENode l_acJs)
                  (break<270>(egr''_ac8P) worklist @a_acJr @l_acJs egr''_ac8P))
               (break<273>(egr''_ac8P)
                null
                  @[]
                  Data.Foldable.$fFoldableList
                  @(ClassId, ENode l_acJs)
                  (break<272>(egr''_ac8P)
                   analysisWorklist @a_acJr @l_acJs egr''_ac8P))
        of {
          False ->
            break<275>(egr''_ac8P)
            rebuild @a_acJr @l_acJs $dAnalysis_acJt $dLanguage_acJu egr''_ac8P;
          True -> egr''_ac8P
        }
        }
end Rec }

-- RHS size: {terms: 167, types: 306, coercions: 39, joins: 0/15}
add [InlPrag=INLINABLE]
  :: forall a (l :: * -> *).
     (Analysis a l, Language l) =>
     ENode l -> EGraph a l -> (ClassId, EGraph a l)
[GblId, Arity=2, Unf=OtherCon []]
add
  = \ (@a_acLn)
      (@(l_acLo :: * -> *))
      ($dAnalysis_acLp :: Analysis a_acLn l_acLo)
      ($dLanguage_acLq :: Language l_acLo) ->
      let {
        $dTraversable_acRC :: Traversable l_acLo
        [LclId]
        $dTraversable_acRC
          = Data.Equality.Language.$p2Language @l_acLo $dLanguage_acLq } in
      let {
        $dFunctor_acRD :: Functor l_acLo
        [LclId]
        $dFunctor_acRD
          = Data.Traversable.$p1Traversable @l_acLo $dTraversable_acRC } in
      let {
        $dFoldable_acME :: Foldable l_acLo
        [LclId]
        $dFoldable_acME
          = Data.Traversable.$p2Traversable @l_acLo $dTraversable_acRC } in
      let {
        df_acRB :: forall {a1}. Ord a1 => Ord (l_acLo a1)
        [LclId]
        df_acRB
          = \ (@a1_i6hG) ->
              Data.Equality.Language.$p1Language
                @l_acLo $dLanguage_acLq @a1_i6hG } in
      let {
        $dOrd_acLB :: Ord (l_acLo ClassId)
        [LclId]
        $dOrd_acLB = df_acRB @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dOrd1_acN6 :: Ord (l_acLo ClassId)
        [LclId]
        $dOrd1_acN6 = df_acRB @Int ghc-prim:GHC.Classes.$fOrdInt } in
      \ (uncanon_e_ac8a :: ENode l_acLo)
        (egr_ac8b :: EGraph a_acLn l_acLo) ->
        case (break<277>(egr_ac8b,uncanon_e_ac8a)
              break<101>(uncanon_e_ac8a,egr_ac8b)
              $ @ghc-prim:GHC.Types.LiftedRep
                @(l_acLo ClassId)
                @(ENode l_acLo)
                ((\ (ds_dcUI :: l_acLo ClassId) -> ds_dcUI)
                 `cast` (<l_acLo ClassId>_R
                         %<Many>_N ->_R Sym (Data.Equality.Graph.Nodes.N:ENode[0]
                                                 <l_acLo>_R)
                         :: (l_acLo ClassId -> l_acLo ClassId)
                            ~R# (l_acLo ClassId -> ENode l_acLo)))
                (break<100>(uncanon_e_ac8a,egr_ac8b)
                 fmap
                   @l_acLo
                   $dFunctor_acRD
                   @ClassId
                   @ClassId
                   (break<99>(egr_ac8b)
                    \ (v_B2 :: ClassId) ->
                      (break<31>(v_B2)
                       . @ReprUnionFind
                         @ClassId
                         @(EGraph a_acLn l_acLo)
                         (break<30>(v_B2) findRepr v_B2)
                         (unionFind @a_acLn @l_acLo))
                        egr_ac8b)
                   (uncanon_e_ac8a
                    `cast` (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R
                            :: ENode l_acLo ~R# l_acLo ClassId))))
             `cast` (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R
                     :: ENode l_acLo ~R# l_acLo ClassId)
        of nt_sd17
        { __DEFAULT ->
        break<310>(egr_ac8b,nt_sd17)
        case break<279>(egr_ac8b,nt_sd17)
             lookupNM
               @l_acLo
               @ClassId
               $dOrd_acLB
               (nt_sd17
                `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R)
                        :: l_acLo ClassId ~R# ENode l_acLo))
               (break<278>(egr_ac8b) memo @a_acLn @l_acLo egr_ac8b)
        of {
          Nothing ->
            let {
              ds_dd0o :: (ClassId, ReprUnionFind)
              [LclId]
              ds_dd0o
                = break<283>(egr_ac8b)
                  makeNewSet
                    (break<282>(egr_ac8b) unionFind @a_acLn @l_acLo egr_ac8b) } in
            let {
              new_eclass_id_ac8e :: ClassId
              [LclId]
              new_eclass_id_ac8e
                = case ds_dd0o of { (new_eclass_id1_X3, new_uf_ac8f) ->
                  new_eclass_id1_X3
                  } } in
            let {
              new_uf_ac8f :: ReprUnionFind
              [LclId]
              new_uf_ac8f
                = case ds_dd0o of { (new_eclass_id1_X3, new_uf1_X4) ->
                  new_uf1_X4
                  } } in
            let {
              new_eclass_ac8g :: EClass a_acLn l_acLo
              [LclId]
              new_eclass_ac8g
                = break<289>(egr_ac8b,nt_sd17,new_eclass_id_ac8e)
                  case new_eclass_id_ac8e of conrep_ibq6
                  { ghc-prim:GHC.Types.I# ipv_sd18 ->
                  case break<284>(nt_sd17)
                       S.singleton
                         @(ENode l_acLo)
                         (nt_sd17
                          `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R)
                                  :: l_acLo ClassId ~R# ENode l_acLo))
                  of conrep1_ibq7
                  { __DEFAULT ->
                  case mempty
                         @(SList (ClassId, ENode l_acLo))
                         (Data.Equality.Utils.SizedList.$fMonoidSList
                            @(ClassId, ENode l_acLo))
                  of conrep2_ibq9
                  { SList ipv1_sd1a ipv2_sd1b ->
                  Data.Equality.Graph.Classes.EClass
                    @a_acLn
                    @l_acLo
                    conrep_ibq6
                    conrep1_ibq7
                    (break<288>(egr_ac8b,nt_sd17)
                     makeA
                       @a_acLn
                       @l_acLo
                       $dAnalysis_acLp
                       (break<287>(egr_ac8b,nt_sd17)
                        <$>
                          @l_acLo
                          @ClassId
                          @a_acLn
                          $dFunctor_acRD
                          (\ (i_ac8l :: ClassId) ->
                             break<285>(i_ac8l,egr_ac8b)
                             ^.
                               @(EGraph a_acLn l_acLo)
                               @a_acLn
                               egr_ac8b
                               (\ (@(f_acM3 :: * -> *)) ($dFunctor1_acM4 :: Functor f_acM3) ->
                                  . @(EClass a_acLn l_acLo -> f_acM3 (EClass a_acLn l_acLo))
                                    @(EGraph a_acLn l_acLo -> f_acM3 (EGraph a_acLn l_acLo))
                                    @(a_acLn -> f_acM3 a_acLn)
                                    (_class @a_acLn @l_acLo i_ac8l @f_acM3 $dFunctor1_acM4)
                                    (_data @a_acLn @l_acLo @a_acLn @f_acM3 $dFunctor1_acM4)))
                          (break<286>(nt_sd17)
                           unNode
                             @l_acLo
                             (nt_sd17
                              `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R)
                                      :: l_acLo ClassId ~R# ENode l_acLo)))))
                    conrep2_ibq9
                  }
                  }
                  } } in
            let {
              new_parents_ac8h
                :: SList (ClassId, ENode l_acLo) -> SList (ClassId, ENode l_acLo)
              [LclId]
              new_parents_ac8h
                = break<291>(nt_sd17,new_eclass_id_ac8e)
                  break<290>(nt_sd17,new_eclass_id_ac8e)
                  let {
                    v_B1
                      :: SList (ClassId, ENode l_acLo) -> SList (ClassId, ENode l_acLo)
                    [LclId]
                    v_B1
                      = |:
                          @(ClassId, ENode l_acLo)
                          (new_eclass_id_ac8e,
                           nt_sd17
                           `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R)
                                   :: l_acLo ClassId ~R# ENode l_acLo)) } in
                  \ (v1_B2 :: SList (ClassId, ENode l_acLo)) -> v_B1 v1_B2 } in
            let {
              new_classes_ac8i :: IM.IntMap (EClass a_acLn l_acLo)
              [LclId]
              new_classes_ac8i
                = break<298>(egr_ac8b,nt_sd17,new_eclass_id_ac8e,new_eclass_ac8g,new_parents_ac8h)
                  $ @ghc-prim:GHC.Types.LiftedRep
                    @(IM.IntMap (EClass a_acLn l_acLo))
                    @(IM.IntMap (EClass a_acLn l_acLo))
                    (break<292>(new_eclass_id_ac8e,new_eclass_ac8g)
                     IM.insert
                       @(EClass a_acLn l_acLo) new_eclass_id_ac8e new_eclass_ac8g)
                    (break<297>(egr_ac8b,nt_sd17,new_parents_ac8h)
                     foldr
                       @l_acLo
                       $dFoldable_acME
                       @IM.Key
                       @(IM.IntMap (EClass a_acLn l_acLo))
                       (break<294>(new_parents_ac8h)
                        IM.adjust
                          @(EClass a_acLn l_acLo)
                          (break<293>(new_parents_ac8h)
                           %~
                             @(EClass a_acLn l_acLo)
                             @(EClass a_acLn l_acLo)
                             @(SList (ClassId, ENode l_acLo))
                             @(SList (ClassId, ENode l_acLo))
                             (_parents
                                @a_acLn
                                @l_acLo
                                @Data.Functor.Identity.Identity
                                Data.Functor.Identity.$fFunctorIdentity)
                             new_parents_ac8h))
                       (break<295>(egr_ac8b) classes @a_acLn @l_acLo egr_ac8b)
                       (break<296>(nt_sd17)
                        unNode
                          @l_acLo
                          (nt_sd17
                           `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R)
                                   :: l_acLo ClassId ~R# ENode l_acLo)))) } in
            let {
              new_worklist_ac8j :: [(ClassId, ENode l_acLo)]
              [LclId]
              new_worklist_ac8j
                = break<300>(egr_ac8b,nt_sd17,new_eclass_id_ac8e)
                  ghc-prim:GHC.Types.:
                    @(ClassId, ENode l_acLo)
                    (new_eclass_id_ac8e,
                     nt_sd17
                     `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R)
                             :: l_acLo ClassId ~R# ENode l_acLo))
                    (break<299>(egr_ac8b) worklist @a_acLn @l_acLo egr_ac8b) } in
            let {
              new_memo_ac8k :: NodeMap l_acLo ClassId
              [LclId]
              new_memo_ac8k
                = break<302>(egr_ac8b,nt_sd17,new_eclass_id_ac8e)
                  insertNM
                    @l_acLo
                    @ClassId
                    $dOrd1_acN6
                    (nt_sd17
                     `cast` (Sym (Data.Equality.Graph.Nodes.N:ENode[0] <l_acLo>_R)
                             :: l_acLo ClassId ~R# ENode l_acLo))
                    new_eclass_id_ac8e
                    (break<301>(egr_ac8b) memo @a_acLn @l_acLo egr_ac8b) } in
            break<309>(egr_ac8b,new_eclass_id_ac8e,new_uf_ac8f,new_classes_ac8i,new_worklist_ac8j,new_memo_ac8k)
            (new_eclass_id_ac8e,
             break<308>(egr_ac8b,new_eclass_id_ac8e,new_uf_ac8f,new_classes_ac8i,new_worklist_ac8j,new_memo_ac8k)
             & @(EGraph a_acLn l_acLo)
               @(EGraph a_acLn l_acLo)
               (case egr_ac8b of
                { EGraph ds1_dd0c ds2_dd0d ds3_dd0e ds4_dd0f analysisWorklist_B5 ->
                case break<303>(new_uf_ac8f) new_uf_ac8f of conrep_ibDH
                { Data.Equality.Graph.ReprUnionFind.RUF ipv_sd1d ipv1_sd1e ->
                case break<304>(new_classes_ac8i) new_classes_ac8i of conrep1_ibDI
                { __DEFAULT ->
                case (break<306>(new_memo_ac8k) new_memo_ac8k)
                     `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                 <l_acLo>_N <ClassId>_N
                             :: NodeMap l_acLo ClassId
                                ~R# Data.Map.Internal.Map (ENode l_acLo) ClassId)
                of nt1_sd1g
                { __DEFAULT ->
                case break<305>(new_worklist_ac8j) new_worklist_ac8j
                of conrep2_ibDK
                { __DEFAULT ->
                Data.Equality.Graph.Internal.EGraph
                  @a_acLn
                  @l_acLo
                  conrep_ibDH
                  conrep1_ibDI
                  (nt1_sd1g
                   `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                                    <l_acLo>_N) <ClassId>_N
                           :: Data.Map.Internal.Map (ENode l_acLo) ClassId
                              ~R# NodeMap l_acLo ClassId))
                  conrep2_ibDK
                  analysisWorklist_B5
                }
                }
                }
                }
                })
               (break<307>(new_eclass_id_ac8e)
                modifyA @a_acLn @l_acLo $dAnalysis_acLp new_eclass_id_ac8e));
          Just canon_enode_id_ac8d ->
            break<281>(egr_ac8b,canon_enode_id_ac8d)
            (break<280>(egr_ac8b,canon_enode_id_ac8d)
             (break<31>(canon_enode_id_ac8d)
              . @ReprUnionFind
                @ClassId
                @(EGraph a_acLn l_acLo)
                (break<30>(canon_enode_id_ac8d) findRepr canon_enode_id_ac8d)
                (unionFind @a_acLn @l_acLo))
               egr_ac8b,
             egr_ac8b)
        }
        }

-- RHS size: {terms: 57, types: 271, coercions: 7, joins: 0/5}
represent
  :: forall a (l :: * -> *).
     (Analysis a l, Language l) =>
     Fix l -> EGraph a l -> (ClassId, EGraph a l)
[GblId, Arity=2, Unf=OtherCon []]
represent
  = \ (@a_acNG)
      (@(l_acNH :: * -> *))
      ($dAnalysis_acNI :: Analysis a_acNG l_acNH)
      ($dLanguage_acNJ :: Language l_acNH) ->
      let {
        $dMonad_acOL
          :: Monad
               (StateT (EGraph a_acNG l_acNH) Data.Functor.Identity.Identity)
        [LclId]
        $dMonad_acOL
          = Control.Monad.Trans.State.Lazy.$fMonadStateT
              @Data.Functor.Identity.Identity
              @(EGraph a_acNG l_acNH)
              Data.Functor.Identity.$fMonadIdentity } in
      let {
        $dFunctor_acOU
          :: Functor
               (StateT (EGraph a_acNG l_acNH) Data.Functor.Identity.Identity)
        [LclId]
        $dFunctor_acOU
          = Control.Monad.Trans.State.Lazy.$fFunctorStateT
              @Data.Functor.Identity.Identity
              @(EGraph a_acNG l_acNH)
              Data.Functor.Identity.$fFunctorIdentity } in
      let {
        $dApplicative_acOC
          :: Applicative
               (StateT (EGraph a_acNG l_acNH) Data.Functor.Identity.Identity)
        [LclId]
        $dApplicative_acOC
          = Control.Monad.Trans.State.Lazy.$fApplicativeStateT
              @Data.Functor.Identity.Identity
              @(EGraph a_acNG l_acNH)
              Data.Functor.Identity.$fFunctorIdentity
              Data.Functor.Identity.$fMonadIdentity } in
      let {
        $dTraversable_acRJ :: Traversable l_acNH
        [LclId]
        $dTraversable_acRJ
          = Data.Equality.Language.$p2Language @l_acNH $dLanguage_acNJ } in
      let {
        $dFunctor1_acNN :: Functor l_acNH
        [LclId]
        $dFunctor1_acNN
          = Data.Traversable.$p1Traversable @l_acNH $dTraversable_acRJ } in
      break<322>()
      cata
        @l_acNH
        @(EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH))
        $dFunctor1_acNN
        (break<321>()
         $ @ghc-prim:GHC.Types.LiftedRep
           @(EGraph a_acNG l_acNH
             -> l_acNH (EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH))
             -> (ClassId, EGraph a_acNG l_acNH))
           @(l_acNH (EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH))
             -> EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH))
           (flip
              @(EGraph a_acNG l_acNH)
              @(l_acNH (EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH)))
              @(ClassId, EGraph a_acNG l_acNH))
           (\ (e_ac87 :: EGraph a_acNG l_acNH) ->
              break<320>(e_ac87)
              . @(ENode l_acNH, EGraph a_acNG l_acNH)
                @(ClassId, EGraph a_acNG l_acNH)
                @(l_acNH (EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH)))
                (break<311>()
                 uncurry
                   @(ENode l_acNH)
                   @(EGraph a_acNG l_acNH)
                   @(ClassId, EGraph a_acNG l_acNH)
                   (add @a_acNG @l_acNH $dAnalysis_acNI $dLanguage_acNJ))
                (break<319>(e_ac87)
                 . @(l_acNH ClassId, EGraph a_acNG l_acNH)
                   @(ENode l_acNH, EGraph a_acNG l_acNH)
                   @(l_acNH (EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH)))
                   (break<312>()
                    first
                      @(,)
                      Data.Bifunctor.$fBifunctor(,)
                      @(l_acNH ClassId)
                      @(ENode l_acNH)
                      @(EGraph a_acNG l_acNH)
                      ((\ (ds_dd0y :: l_acNH ClassId) -> ds_dd0y)
                       `cast` (<l_acNH ClassId>_R
                               %<Many>_N ->_R Sym (Data.Equality.Graph.Nodes.N:ENode[0]
                                                       <l_acNH>_R)
                               :: (l_acNH ClassId -> l_acNH ClassId)
                                  ~R# (l_acNH ClassId -> ENode l_acNH))))
                   (break<318>(e_ac87)
                    . @(State (EGraph a_acNG l_acNH) (l_acNH ClassId))
                      @(l_acNH ClassId, EGraph a_acNG l_acNH)
                      @(l_acNH (EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH)))
                      (break<313>(e_ac87)
                       \ (v_B2 :: State (EGraph a_acNG l_acNH) (l_acNH ClassId)) ->
                         runState @(EGraph a_acNG l_acNH) @(l_acNH ClassId) v_B2 e_ac87)
                      (break<317>()
                       traverse
                         @l_acNH
                         $dTraversable_acRJ
                         @(StateT (EGraph a_acNG l_acNH) Data.Functor.Identity.Identity)
                         @(EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH))
                         @ClassId
                         $dApplicative_acOC
                         (break<316>()
                          >=>
                            @(StateT (EGraph a_acNG l_acNH) Data.Functor.Identity.Identity)
                            @(EGraph a_acNG l_acNH -> (ClassId, EGraph a_acNG l_acNH))
                            @(ClassId, EGraph a_acNG l_acNH)
                            @ClassId
                            $dMonad_acOL
                            (gets
                               @Data.Functor.Identity.Identity
                               @(EGraph a_acNG l_acNH)
                               @(ClassId, EGraph a_acNG l_acNH)
                               Data.Functor.Identity.$fMonadIdentity)
                            (\ (ds_dd0z :: (ClassId, EGraph a_acNG l_acNH)) ->
                               case ds_dd0z of { (x_ac88, e'_ac89) ->
                               break<315>(x_ac88,e'_ac89)
                               <$
                                 @(StateT (EGraph a_acNG l_acNH) Data.Functor.Identity.Identity)
                                 $dFunctor_acOU
                                 @ClassId
                                 @()
                                 x_ac88
                                 (break<314>(e'_ac89)
                                  put
                                    @Data.Functor.Identity.Identity
                                    @(EGraph a_acNG l_acNH)
                                    Data.Functor.Identity.$fMonadIdentity
                                    e'_ac89)
                               })))))))

-- RHS size: {terms: 35, types: 53, coercions: 7, joins: 0/2}
emptyEGraph [InlPrag=INLINE (sat-args=0)]
  :: forall (l :: * -> *) a. Language l => EGraph a l
[GblId, Arity=1, Unf=OtherCon []]
emptyEGraph
  = \ (@(l_acmu :: * -> *))
      (@a_acmv)
      ($dLanguage_acmw :: Language l_acmu) ->
      let {
        $dOrd_acPw :: Ord (l_acmu ClassId)
        [LclId]
        $dOrd_acPw
          = Data.Equality.Language.$p1Language
              @l_acmu $dLanguage_acmw @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dMonoid_acmI :: Monoid (Memo l_acmu)
        [LclId]
        $dMonoid_acmI
          = Data.Equality.Graph.Nodes.$fMonoidNodeMap
              @l_acmu @Int $dOrd_acPw } in
      break<29>()
      case emptyUF of conrep_ibDH
      { Data.Equality.Graph.ReprUnionFind.RUF ipv_sd1i ipv1_sd1j ->
      case mempty
             @(ClassIdMap (EClass a_acmv l_acmu))
             (Data.IntMap.Internal.$fMonoidIntMap @(EClass a_acmv l_acmu))
      of conrep1_ibDI
      { __DEFAULT ->
      case (mempty @(Memo l_acmu) $dMonoid_acmI)
           `cast` (Data.Equality.Graph.Nodes.N:NodeMap[0]
                       <l_acmu>_N <ClassId>_N
                   :: NodeMap l_acmu ClassId
                      ~R# Data.Map.Internal.Map (ENode l_acmu) ClassId)
      of nt_sd1l
      { __DEFAULT ->
      case mempty
             @(Worklist l_acmu) (GHC.Base.$fMonoidList @(ClassId, ENode l_acmu))
      of conrep2_ibDK
      { __DEFAULT ->
      case mempty
             @(Worklist l_acmu) (GHC.Base.$fMonoidList @(ClassId, ENode l_acmu))
      of conrep3_ibDL
      { __DEFAULT ->
      Data.Equality.Graph.Internal.EGraph
        @a_acmv
        @l_acmu
        conrep_ibDH
        conrep1_ibDI
        (nt_sd1l
         `cast` (Sym (Data.Equality.Graph.Nodes.N:NodeMap[0]
                          <l_acmu>_N) <ClassId>_N
                 :: Data.Map.Internal.Map (ENode l_acmu) ClassId
                    ~R# NodeMap l_acmu ClassId))
        conrep2_ibDK
        conrep3_ibDL
      }
      }
      }
      }
      }

-- RHS size: {terms: 56, types: 90, coercions: 0, joins: 0/4}
newEClass [InlPrag=INLINE (sat-args=2)]
  :: forall (l :: * -> *) a.
     Language l =>
     a -> EGraph a l -> (ClassId, EGraph a l)
[GblId, Arity=3, Unf=OtherCon []]
newEClass
  = \ (@(l_aclM :: * -> *))
      (@a_aclN)
      _ [Occ=Dead]
      (eta_B0 :: a_aclN)
      (egr_ac96 :: EGraph a_aclN l_aclM) ->
      let {
        ds_dcTx :: (ClassId, ReprUnionFind)
        [LclId]
        ds_dcTx
          = break<23>(egr_ac96)
            makeNewSet
              (break<22>(egr_ac96) unionFind @a_aclN @l_aclM egr_ac96) } in
      let {
        new_eclass_id_ac97 :: ClassId
        [LclId]
        new_eclass_id_ac97
          = case ds_dcTx of { (new_eclass_id1_X2, new_uf_X3) ->
            new_eclass_id1_X2
            } } in
      let {
        new_uf_ac98 :: ReprUnionFind
        [LclId]
        new_uf_ac98
          = case ds_dcTx of { (new_eclass_id1_X2, new_uf1_X3) ->
            new_uf1_X3
            } } in
      let {
        new_eclass_ac99 :: EClass a_aclN l_aclM
        [LclId]
        new_eclass_ac99
          = break<24>(new_eclass_id_ac97,eta_B0)
            case new_eclass_id_ac97 of conrep_ibq6
            { ghc-prim:GHC.Types.I# ipv_sd1m ->
            case S.empty @(ENode l_aclM) of conrep1_ibq7 { __DEFAULT ->
            case mempty
                   @(SList (ClassId, ENode l_aclM))
                   (Data.Equality.Utils.SizedList.$fMonoidSList
                      @(ClassId, ENode l_aclM))
            of conrep2_ibq9
            { SList ipv1_sd1o ipv2_sd1p ->
            Data.Equality.Graph.Classes.EClass
              @a_aclN @l_aclM conrep_ibq6 conrep1_ibq7 eta_B0 conrep2_ibq9
            }
            }
            } } in
      break<28>(egr_ac96,new_eclass_id_ac97,new_uf_ac98,new_eclass_ac99)
      (new_eclass_id_ac97,
       case egr_ac96 of wild_X1
       { EGraph ds1_dcTr ds2_dcTs memo_B3 worklist_B4
                analysisWorklist_B5 ->
       case break<25>(new_uf_ac98) new_uf_ac98 of conrep_ibDH
       { Data.Equality.Graph.ReprUnionFind.RUF ipv_sd1r ipv1_sd1s ->
       case break<27>(egr_ac96,new_eclass_id_ac97,new_eclass_ac99)
            IM.insert
              @(EClass a_aclN l_aclM)
              new_eclass_id_ac97
              new_eclass_ac99
              (break<26>(egr_ac96) classes @a_aclN @l_aclM wild_X1)
       of conrep1_ibDI
       { __DEFAULT ->
       Data.Equality.Graph.Internal.EGraph
         @a_aclN
         @l_aclM
         conrep_ibDH
         conrep1_ibDI
         memo_B3
         worklist_B4
         analysisWorklist_B5
       }
       }
       })

-- RHS size: {terms: 100, types: 183, coercions: 0, joins: 0/5}
repairAnalM [InlPrag=INLINE (sat-args=2)]
  :: forall a (l :: * -> *) (m :: * -> *).
     (AM.AnalysisM m a l, Language l) =>
     (ClassId, ENode l) -> EGraph a l -> m (EGraph a l)
[GblId, Arity=4, Unf=OtherCon []]
repairAnalM
  = \ (@a_acj2)
      (@(l_acj3 :: * -> *))
      (@(m_acj4 :: * -> *))
      ($dAnalysisM_acj5 :: AM.AnalysisM m_acj4 a_acj2 l_acj3)
      ($dLanguage_acj6 :: Language l_acj3)
      (eta_B0 :: (ClassId, ENode l_acj3))
      (eta1_B1 :: EGraph a_acj2 l_acj3) ->
      let {
        $dFunctor_sd1u :: Traversable l_acj3
        [LclId]
        $dFunctor_sd1u
          = Data.Equality.Language.$p2Language @l_acj3 $dLanguage_acj6 } in
      let {
        $dFunctor1_acjV :: Functor l_acj3
        [LclId]
        $dFunctor1_acjV
          = Data.Traversable.$p1Traversable @l_acj3 $dFunctor_sd1u } in
      let {
        $dEq_ackp :: Eq a_acj2
        [LclId]
        $dEq_ackp
          = Data.Equality.Analysis.Monadic.$p2AnalysisM
              @m_acj4 @a_acj2 @l_acj3 $dAnalysisM_acj5 } in
      let {
        $dMonad_acP4 :: Monad m_acj4
        [LclId]
        $dMonad_acP4
          = Data.Equality.Analysis.Monadic.$p1AnalysisM
              @m_acj4 @a_acj2 @l_acj3 $dAnalysisM_acj5 } in
      case eta_B0 of { (repair_id_aca3, node_aca4) ->
      break<21>(eta1_B1,repair_id_aca3,node_aca4)
      let {
        c_aca6 :: EClass a_acj2 l_acj3
        [LclId]
        c_aca6
          = break<0>(eta1_B1,repair_id_aca3)
            ^.
              @(EGraph a_acj2 l_acj3)
              @(EClass a_acj2 l_acj3)
              eta1_B1
              (\ (@(f_acjc :: * -> *)) ($dFunctor2_acjd :: Functor f_acjc) ->
                 _class @a_acj2 @l_acj3 repair_id_aca3 @f_acjc $dFunctor2_acjd) } in
      >>=
        @m_acj4
        $dMonad_acP4
        @a_acj2
        @(EGraph a_acj2 l_acj3)
        (break<8>(c_aca6,eta1_B1,node_aca4)
         =<<
           @m_acj4
           @a_acj2
           @a_acj2
           $dMonad_acP4
           (break<2>(c_aca6)
            AM.joinA
              @m_acj4
              @a_acj2
              @l_acj3
              $dAnalysisM_acj5
              (break<1>(c_aca6)
               ^.
                 @(EClass a_acj2 l_acj3)
                 @a_acj2
                 c_aca6
                 (_data @a_acj2 @l_acj3 @a_acj2)))
           (break<7>(eta1_B1,node_aca4)
            AM.makeA
              @m_acj4
              @a_acj2
              @l_acj3
              $dAnalysisM_acj5
              (break<6>(eta1_B1,node_aca4)
               <$>
                 @l_acj3
                 @ClassId
                 @a_acj2
                 $dFunctor1_acjV
                 (\ (i_aca7 :: ClassId) ->
                    break<4>(i_aca7,eta1_B1)
                    ^.
                      @(EClass a_acj2 l_acj3)
                      @a_acj2
                      (break<3>(i_aca7,eta1_B1)
                       ^.
                         @(EGraph a_acj2 l_acj3)
                         @(EClass a_acj2 l_acj3)
                         eta1_B1
                         (\ (@(f_ack0 :: * -> *)) ($dFunctor2_ack1 :: Functor f_ack0) ->
                            _class @a_acj2 @l_acj3 i_aca7 @f_ack0 $dFunctor2_ack1))
                      (_data @a_acj2 @l_acj3 @a_acj2))
                 (break<5>(node_aca4) unNode @l_acj3 node_aca4))))
        (\ (new_data_aca8 :: a_acj2) ->
           case break<10>(c_aca6,new_data_aca8)
                /=
                  @a_acj2
                  $dEq_ackp
                  (break<9>(c_aca6)
                   ^.
                     @(EClass a_acj2 l_acj3)
                     @a_acj2
                     c_aca6
                     (_data @a_acj2 @l_acj3 @a_acj2))
                  new_data_aca8
           of {
             False ->
               break<20>(eta1_B1)
               return @m_acj4 $dMonad_acP4 @(EGraph a_acj2 l_acj3) eta1_B1;
             True ->
               break<19>(c_aca6,eta1_B1,new_data_aca8,repair_id_aca3)
               & @(EGraph a_acj2 l_acj3)
                 @(m_acj4 (EGraph a_acj2 l_acj3))
                 (case eta1_B1 of wild2_X3
                  { EGraph unionFind_X4 ds_dcTc memo_B3 worklist_B4 ds1_dcTd ->
                  case break<17>(eta1_B1,new_data_aca8,repair_id_aca3)
                       IM.adjust
                         @(EClass a_acj2 l_acj3)
                         (break<15>(new_data_aca8)
                          .~
                            @(EClass a_acj2 l_acj3)
                            @a_acj2
                            (_data @a_acj2 @l_acj3 @a_acj2)
                            new_data_aca8)
                         repair_id_aca3
                         (break<16>(eta1_B1) classes @a_acj2 @l_acj3 wild2_X3)
                  of conrep_ibDI
                  { __DEFAULT ->
                  case break<14>(c_aca6,eta1_B1)
                       <>
                         @(Worklist l_acj3)
                         (GHC.Base.$fSemigroupList @(ClassId, ENode l_acj3))
                         (break<12>(c_aca6)
                          toListSL
                            @(ClassId, ENode l_acj3)
                            (break<11>(c_aca6)
                             ^.
                               @(EClass a_acj2 l_acj3)
                               @(SList (ClassId, ENode l_acj3))
                               c_aca6
                               (_parents @a_acj2 @l_acj3)))
                         (break<13>(eta1_B1) analysisWorklist @a_acj2 @l_acj3 wild2_X3)
                  of conrep1_ibDL
                  { __DEFAULT ->
                  Data.Equality.Graph.Internal.EGraph
                    @a_acj2
                    @l_acj3
                    unionFind_X4
                    conrep_ibDI
                    memo_B3
                    worklist_B4
                    conrep1_ibDL
                  }
                  }
                  })
                 (break<18>(repair_id_aca3)
                  AM.modifyA @m_acj4 @a_acj2 @l_acj3 $dAnalysisM_acj5 repair_id_aca3)
           })
      }

Rec {
-- RHS size: {terms: 130, types: 274, coercions: 9, joins: 0/9}
rebuildM [InlPrag=INLINABLE, Occ=LoopBreaker]
  :: forall a (l :: * -> *) (m :: * -> *).
     (AM.AnalysisM m a l, Language l) =>
     EGraph a l -> m (EGraph a l)
[GblId, Arity=2, Unf=OtherCon []]
rebuildM
  = \ (@a_acys)
      (@(l_acyt :: * -> *))
      (@(m_acyu :: * -> *))
      ($dAnalysisM_acyv :: AM.AnalysisM m_acyu a_acys l_acyt)
      ($dLanguage_acyw :: Language l_acyt) ->
      let {
        $dFunctor_sd1w :: Traversable l_acyt
        [LclId]
        $dFunctor_sd1w
          = Data.Equality.Language.$p2Language @l_acyt $dLanguage_acyw } in
      let {
        $dFunctor1_aczs :: Functor l_acyt
        [LclId]
        $dFunctor1_aczs
          = Data.Traversable.$p1Traversable @l_acyt $dFunctor_sd1w } in
      let {
        $dOrd_acQO :: Ord (l_acyt ClassId)
        [LclId]
        $dOrd_acQO
          = Data.Equality.Language.$p1Language
              @l_acyt $dLanguage_acyw @Int ghc-prim:GHC.Classes.$fOrdInt } in
      let {
        $dOrd1_acQN :: Ord (ENode l_acyt)
        [LclId]
        $dOrd1_acQN
          = Data.Equality.Graph.Nodes.$fOrdENode @l_acyt $dOrd_acQO } in
      let {
        $dOrd2_acyT :: Ord (ClassId, ENode l_acyt)
        [LclId]
        $dOrd2_acyT
          = ghc-prim:GHC.Classes.$fOrd(,)
              @Int @(ENode l_acyt) ghc-prim:GHC.Classes.$fOrdInt $dOrd1_acQN } in
      let {
        $dMonad_acQB :: Monad m_acyu
        [LclId]
        $dMonad_acQB
          = Data.Equality.Analysis.Monadic.$p1AnalysisM
              @m_acyu @a_acys @l_acyt $dAnalysisM_acyv } in
      \ (ds_dcVv :: EGraph a_acys l_acyt) ->
        case ds_dcVv of
        { EGraph uf_ac9N cls_ac9O mm_ac9P wl_ac9Q awl_ac9R ->
        break<171>(cls_ac9O,uf_ac9N,mm_ac9P,wl_ac9Q,awl_ac9R)
        let {
          emptiedEgr_ac9S :: EGraph a_acys l_acyt
          [LclId]
          emptiedEgr_ac9S
            = break<149>(cls_ac9O,uf_ac9N,mm_ac9P)
              case mempty
                     @(Worklist l_acyt) (GHC.Base.$fMonoidList @(ClassId, ENode l_acyt))
              of conrep_ibDK
              { __DEFAULT ->
              case mempty
                     @(Worklist l_acyt) (GHC.Base.$fMonoidList @(ClassId, ENode l_acyt))
              of conrep1_ibDL
              { __DEFAULT ->
              Data.Equality.Graph.Internal.EGraph
                @a_acys @l_acyt uf_ac9N cls_ac9O mm_ac9P conrep_ibDK conrep1_ibDL
              }
              } } in
        let {
          wl'_ac9T :: [(ClassId, ENode l_acyt)]
          [LclId]
          wl'_ac9T
            = break<154>(wl_ac9Q,emptiedEgr_ac9S)
              $ @ghc-prim:GHC.Types.LiftedRep
                @[(ClassId, ENode l_acyt)]
                @[(ClassId, ENode l_acyt)]
                (nubOrd @(ClassId, ENode l_acyt) $dOrd2_acyT)
                (break<153>(wl_ac9Q,emptiedEgr_ac9S)
                 <$>
                   @[]
                   @(ClassId, ENode l_acyt)
                   @(ClassId, ENode l_acyt)
                   GHC.Base.$fFunctorList
                   (break<152>(emptiedEgr_ac9S)
                    bimap
                      @(,)
                      Data.Bifunctor.$fBifunctor(,)
                      @ClassId
                      @ClassId
                      @(ENode l_acyt)
                      @(ENode l_acyt)
                      (break<150>(emptiedEgr_ac9S)
                       \ (v_B2 :: ClassId) ->
                         (break<31>(v_B2)
                          . @ReprUnionFind
                            @ClassId
                            @(EGraph a_acys l_acyt)
                            (break<30>(v_B2) findRepr v_B2)
                            (unionFind @a_acys @l_acyt))
                           emptiedEgr_ac9S)
                      (break<151>(emptiedEgr_ac9S)
                       \ (v_B2 :: ENode l_acyt) ->
                         break<101>(v_B2,emptiedEgr_ac9S)
                         $ @ghc-prim:GHC.Types.LiftedRep
                           @(l_acyt ClassId)
                           @(ENode l_acyt)
                           ((\ (ds1_dcUI :: l_acyt ClassId) -> ds1_dcUI)
                            `cast` (<l_acyt ClassId>_R
                                    %<Many>_N ->_R Sym (Data.Equality.Graph.Nodes.N:ENode[0]
                                                            <l_acyt>_R)
                                    :: (l_acyt ClassId -> l_acyt ClassId)
                                       ~R# (l_acyt ClassId -> ENode l_acyt)))
                           (break<100>(v_B2,emptiedEgr_ac9S)
                            fmap
                              @l_acyt
                              $dFunctor1_aczs
                              @ClassId
                              @ClassId
                              (break<99>(emptiedEgr_ac9S)
                               \ (v1_X2 :: ClassId) ->
                                 (break<31>(v1_X2)
                                  . @ReprUnionFind
                                    @ClassId
                                    @(EGraph a_acys l_acyt)
                                    (break<30>(v1_X2) findRepr v1_X2)
                                    (unionFind @a_acys @l_acyt))
                                   emptiedEgr_ac9S)
                              (v_B2
                               `cast` (Data.Equality.Graph.Nodes.N:ENode[0] <l_acyt>_R
                                       :: ENode l_acyt ~R# l_acyt ClassId)))))
                   wl_ac9Q) } in
        >>=
          @m_acyu
          $dMonad_acQB
          @(EGraph a_acys l_acyt)
          @(EGraph a_acys l_acyt)
          (break<156>(emptiedEgr_ac9S,wl'_ac9T)
           foldlM
             @[]
             @m_acyu
             @(EGraph a_acys l_acyt)
             @(ClassId, ENode l_acyt)
             Data.Foldable.$fFoldableList
             $dMonad_acQB
             (break<155>()
              flip
                @(ClassId, ENode l_acyt)
                @(EGraph a_acys l_acyt)
                @(m_acyu (EGraph a_acys l_acyt))
                (repairM @a_acys @l_acyt @m_acyu $dAnalysisM_acyv $dLanguage_acyw))
             emptiedEgr_ac9S
             wl'_ac9T)
          (\ (egr'_ac9U :: EGraph a_acys l_acyt) ->
             let {
               awl'_ac9V :: [(Int, ENode l_acyt)]
               [LclId]
               awl'_ac9V
                 = break<161>(awl_ac9R,egr'_ac9U)
                   $ @ghc-prim:GHC.Types.LiftedRep
                     @[(Int, ENode l_acyt)]
                     @[(Int, ENode l_acyt)]
                     (break<157>()
                      nubIntOn @(Int, ENode l_acyt) (fst @Int @(ENode l_acyt)))
                     (break<160>(awl_ac9R,egr'_ac9U)
                      <$>
                        @[]
                        @(ClassId, ENode l_acyt)
                        @(Int, ENode l_acyt)
                        GHC.Base.$fFunctorList
                        (break<159>(egr'_ac9U)
                         first
                           @(,)
                           Data.Bifunctor.$fBifunctor(,)
                           @ClassId
                           @Int
                           @(ENode l_acyt)
                           (break<158>(egr'_ac9U)
                            \ (v_B2 :: ClassId) ->
                              (break<31>(v_B2)
                               . @ReprUnionFind
                                 @ClassId
                                 @(EGraph a_acys l_acyt)
                                 (break<30>(v_B2) findRepr v_B2)
                                 (unionFind @a_acys @l_acyt))
                                egr'_ac9U))
                        awl_ac9R) } in
             >>=
               @m_acyu
               $dMonad_acQB
               @(EGraph a_acys l_acyt)
               @(EGraph a_acys l_acyt)
               (break<163>(egr'_ac9U,awl'_ac9V)
                foldlM
                  @[]
                  @m_acyu
                  @(EGraph a_acys l_acyt)
                  @(ClassId, ENode l_acyt)
                  Data.Foldable.$fFoldableList
                  $dMonad_acQB
                  (break<162>()
                   flip
                     @(ClassId, ENode l_acyt)
                     @(EGraph a_acys l_acyt)
                     @(m_acyu (EGraph a_acys l_acyt))
                     (repairAnalM
                        @a_acys @l_acyt @m_acyu $dAnalysisM_acyv $dLanguage_acyw))
                  egr'_ac9U
                  awl'_ac9V)
               (\ (egr''_ac9W :: EGraph a_acys l_acyt) ->
                  case break<168>(egr''_ac9W)
                       &&
                         (break<165>(egr''_ac9W)
                          null
                            @[]
                            Data.Foldable.$fFoldableList
                            @(ClassId, ENode l_acyt)
                            (break<164>(egr''_ac9W) worklist @a_acys @l_acyt egr''_ac9W))
                         (break<167>(egr''_ac9W)
                          null
                            @[]
                            Data.Foldable.$fFoldableList
                            @(ClassId, ENode l_acyt)
                            (break<166>(egr''_ac9W)
                             analysisWorklist @a_acys @l_acyt egr''_ac9W))
                  of {
                    False ->
                      break<170>(egr''_ac9W)
                      rebuildM
                        @a_acys
                        @l_acyt
                        @m_acyu
                        $dAnalysisM_acyv
                        $dLanguage_acyw
                        egr''_ac9W;
                    True ->
                      break<169>(egr''_ac9W)
                      return @m_acyu $dMonad_acQB @(EGraph a_acys l_acyt) egr''_ac9W
                  }))
        }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule1_rd1C :: ghc-prim:GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
$trModule1_rd1C = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule2_rd1D :: ghc-prim:GHC.Types.TrName
[GblId, Unf=OtherCon []]
$trModule2_rd1D = ghc-prim:GHC.Types.TrNameS $trModule1_rd1C

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule3_rd1E :: ghc-prim:GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
$trModule3_rd1E = "Data.Equality.Graph"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule4_rd1F :: ghc-prim:GHC.Types.TrName
[GblId, Unf=OtherCon []]
$trModule4_rd1F = ghc-prim:GHC.Types.TrNameS $trModule3_rd1E

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Equality.Graph.$trModule :: ghc-prim:GHC.Types.Module
[GblId, Unf=OtherCon []]
Data.Equality.Graph.$trModule
  = ghc-prim:GHC.Types.Module $trModule2_rd1D $trModule4_rd1F


